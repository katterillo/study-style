/**
 * Bundle of @devexpress/dx-scheduler-core
 * Generated: 2022-02-24
 * Version: 3.0.2
 * License: https://js.devexpress.com/Licensing
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment'), require('rrule'), require('@devexpress/dx-core')) :
    typeof define === 'function' && define.amd ? define(['exports', 'moment', 'rrule', '@devexpress/dx-core'], factory) :
    (global = global || self, factory((global.DevExpress = global.DevExpress || {}, global.DevExpress.DXSchedulerCore = {}), global.moment, global.rrule, global.DevExpress.DXCore));
}(this, (function (exports, moment, rrule, dxCore) { 'use strict';

    if (typeof process === "undefined") { var process = { env: {} }; }

    moment = moment && Object.prototype.hasOwnProperty.call(moment, 'default') ? moment['default'] : moment;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var computed = function (getters, viewName, baseComputed, defaultValue) {
        if (getters.currentView.name !== viewName && !!defaultValue) {
            return defaultValue;
        }
        return baseComputed(getters, viewName);
    };
    var toPercentage = function (value, total) { return (value * 100) / total; };
    var createExcludedInterval = function (day, start) {
        var leftBound = moment(start.day(day));
        return [
            leftBound,
            moment(leftBound).hour(start.hour()).endOf('day'),
        ];
    };
    var excludedIntervals = function (excludedDays, start) { return excludedDays
        .map(function (day) { return (day === 0 ? 7 : day); })
        .sort(function (a, b) { return a - b; })
        .reduce(function (acc, day, i, allDays) {
        if (i && day === allDays[i - 1] + 1) {
            acc[acc.length - 1][1].day(day);
        }
        else {
            acc.push(createExcludedInterval(day, start));
        }
        return acc;
    }, []); };
    var inInterval = function (date, interval) { return date.isBetween(interval[0], interval[1], undefined, '[]'); };
    var viewPredicate = function (appointment, left, right, excludedDays, removeAllDayAppointments) {
        if (excludedDays === void 0) { excludedDays = []; }
        if (removeAllDayAppointments === void 0) { removeAllDayAppointments = false; }
        var start = appointment.start, end = appointment.end;
        var isAppointmentInBoundary = end.isAfter(left)
            && start.isBefore(right);
        var isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment(left))
            .find(function (interval) { return (inInterval(start, interval) && inInterval(end, interval)); });
        var considerAllDayAppointment = removeAllDayAppointments
            ? moment(end).diff(start, 'hours') < 24 && !appointment.allDay
            : true;
        return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;
    };
    var calculateFirstDateOfWeek = function (currentDate, firstDayOfWeek, excludedDays) {
        if (excludedDays === void 0) { excludedDays = []; }
        var currentLocale = moment.locale();
        moment.updateLocale('tmp-locale', {
            week: { dow: firstDayOfWeek, doy: 1 },
        });
        var firstDateOfWeek = moment(currentDate).startOf('week');
        if (excludedDays.indexOf(firstDayOfWeek) !== -1) {
            excludedDays.slice().sort().forEach(function (day) {
                if (day === firstDateOfWeek.day()) {
                    firstDateOfWeek.add(1, 'days');
                }
            });
        }
        moment.locale(currentLocale);
        return firstDateOfWeek.toDate();
    };
    var getAppointmentStyle = function (_a) {
        var top = _a.top, left = _a.left, width = _a.width, height = _a.height;
        return ({
            height: height,
            width: width + "%",
            transform: "translateY(" + top + "px)",
            msTransform: "translateY(" + top + "px)",
            left: left + "%",
            position: 'absolute',
        });
    };
    var expandRecurrenceAppointment = function (appointment, leftBound, rightBound) {
        var rightBoundUTC = moment(getUTCDate(rightBound)).toDate();
        var leftBoundUTC = moment(getUTCDate(leftBound)).toDate();
        var appointmentStartDate = moment(appointment.start).toDate();
        var options = __assign(__assign({}, rrule.RRule.parseString(appointment.rRule)), { dtstart: moment(getUTCDate(appointmentStartDate)).toDate() });
        var correctedOptions = options.until
            ? __assign(__assign({}, options), { until: moment(getUTCDate(options.until)).toDate() }) : options;
        var rruleSet = getRRuleSetWithExDates(appointment.exDate);
        rruleSet.rrule(new rrule.RRule(correctedOptions));
        // According to https://github.com/jakubroztocil/rrule#important-use-utc-dates
        // we have to format the dates we get from RRuleSet to get local dates
        var datesInBoundaries = rruleSet.between(leftBoundUTC, rightBoundUTC, true)
            .map(formatDateToString);
        if (datesInBoundaries.length === 0)
            return [];
        var appointmentDuration = moment(appointment.end)
            .diff(appointment.start, 'minutes');
        return datesInBoundaries.map(function (startDate, index) { return (__assign(__assign({}, appointment), { dataItem: __assign(__assign({}, appointment.dataItem), { startDate: moment(startDate).toDate(), endDate: moment(startDate).add(appointmentDuration, 'minutes').toDate(), parentData: appointment.dataItem }), start: moment(startDate), end: moment(startDate).add(appointmentDuration, 'minutes'), key: appointment.key + "_rec_" + index })); });
    };
    var filterByViewBoundaries = function (appointment, leftBound, rightBound, excludedDays, removeAllDay) {
        var appointments = [appointment];
        if (appointment.rRule) {
            appointments = expandRecurrenceAppointment(appointment, leftBound, rightBound);
        }
        return appointments.filter(function (appt) { return viewPredicate(appt, leftBound, rightBound, excludedDays, removeAllDay); });
    };
    var getUTCDate = function (date) {
        return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());
    };
    var getRRuleSetWithExDates = function (exDate) {
        var rruleSet = new rrule.RRuleSet();
        if (exDate) {
            exDate.split(',').map(function (date) {
                var currentExDate = moment(date).toDate();
                rruleSet.exdate(moment(getUTCDate(currentExDate)).toDate());
            });
        }
        return rruleSet;
    };
    var formatDateToString = function (date) { return moment.utc(date).format('YYYY-MM-DDTHH:mm'); };
    var addDateToKey = function (prevKey, momentDate) { return prevKey + "_" + momentDate.toDate().toString(); };

    var VERTICAL_TYPE = 'vertical';
    var HORIZONTAL_TYPE = 'horizontal';
    var SCROLL_OFFSET = 50;
    var SCROLL_SPEED_PX = 15;
    var SECONDS = 'seconds';
    var MINUTES = 'minutes';
    var HOURS = 'hours';
    var RESIZE_TOP = 'resize-start';
    var RESIZE_BOTTOM = 'resize-end';
    var POSITION_START = 'start';
    var POSITION_END = 'end';
    var AUTO_HEIGHT = 'auto';
    var DAY_OPTIONS = { day: 'numeric' };
    var WEEK_DAY_OPTIONS = { weekday: 'short' };
    var SHORT_MONTH_OPTIONS = { month: 'short' };
    var HOUR_MINUTE_OPTIONS = { hour: 'numeric', minute: 'numeric' };
    var MONTH_YEAR_OPTIONS = { month: 'long', year: 'numeric' };
    var DAY_SHORT_MONTH_OPTIONS = { day: 'numeric', month: 'short' };
    var SHORT_MONTH_LONG_YEAR_OPTIONS = { month: 'short', year: 'numeric' };
    var SHORT_MONTH_SHORT_YEAR_OPTIONS = { month: 'short', year: '2-digit' };
    var DAY_LONG_MONTH_LONG_YEAR_OPTIONS = { day: 'numeric', month: 'long', year: 'numeric' };
    var DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {
        day: 'numeric', month: 'short', year: 'numeric',
    };
    var DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {
        day: 'numeric', month: 'short', year: '2-digit',
    };
    var LONG_WEEK_DAY_OPTIONS = { weekday: 'long' };
    var LONG_MONTH_OPTIONS = { month: 'long' };
    var DAY_LONG_MONTH_OPTIONS = { day: 'numeric', month: 'long' };
    var EMPTY_OPTIONS = {};
    var RECURRENCE_EDIT_SCOPE = {
        ALL: 'all',
        CURRENT_AND_FOLLOWING: 'currentAndFollowing',
        CURRENT: 'current',
    };
    var TOGGLE_APPOINTMENT_FORM_VISIBILITY = 'toggleAppointmentFormVisibility';
    var TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = 'toggleAppointmentTooltipVisibility';
    var WEEKDAY_INTERVAL = 'weekdayInterval';
    var VERTICAL_VIEW_LEFT_OFFSET = 80;
    var HORIZONTAL_VIEW_LEFT_OFFSET = 0;
    var VERTICAL_GROUP_ORIENTATION = 'Vertical';
    var HORIZONTAL_GROUP_ORIENTATION = 'Horizontal';
    var VIEW_TYPES = {
        MONTH: 'month',
        WEEK: 'week',
        DAY: 'day',
        ALL_DAY_PANEL: 'allDayPanel',
    };

    var MONTH_TYPE = 'month';
    var getViewType = function (currentViewType) {
        if (currentViewType === MONTH_TYPE)
            return HORIZONTAL_TYPE;
        return VERTICAL_TYPE;
    };
    var isMidnight = function (date) {
        var momentDate = moment(date);
        return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;
    };
    var calculateTextByDays = function (startViewDate, endViewDate, formatDate, additionalOptions) {
        var momentStartViewDate = moment(startViewDate);
        var momentEndViewDate = moment(endViewDate);
        if (momentStartViewDate.isSame(momentEndViewDate, 'day')) {
            return formatDate(momentStartViewDate.toDate(), __assign(__assign({}, DAY_LONG_MONTH_LONG_YEAR_OPTIONS), additionalOptions));
        }
        if (momentStartViewDate.isSame(momentEndViewDate, 'year')) {
            if (momentStartViewDate.isSame(momentEndViewDate, 'month')) {
                return formatDate(momentStartViewDate.toDate(), DAY_OPTIONS) + "-" + formatDate(momentEndViewDate.toDate(), DAY_OPTIONS) + " " + formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS);
            }
            return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS) + " - " + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS);
        }
        return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS) + " - " + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS);
    };
    var calculateTextByMonths = function (currentDate, intervalCount, formatDate) {
        var momentCurrentDate = moment(currentDate);
        if (intervalCount === 1) {
            return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);
        }
        var lastMonth = momentCurrentDate.clone().add(intervalCount - 1, 'month');
        if (momentCurrentDate.isSame(lastMonth, 'year')) {
            return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS) + "-" + formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS);
        }
        return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS) + " - " + formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS);
    };
    var viewBoundText = function (startViewDate, endViewDate, type, currentDate, intervalCount, formatDate) { return (type !== 'month'
        ? calculateTextByDays(startViewDate, endViewDate, formatDate, type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS)
        : calculateTextByMonths(currentDate, intervalCount, formatDate)); };
    var checkCellGroupingInfo = function (cell, appointment) { return cell.groupingInfo
        ? cell.groupingInfo.every(function (group) { return (group.id === appointment[group.fieldName]); })
        : true; };
    var isDateValid = function (date) { return moment(date).isValid(); };
    var convertToMoment = function (date) { return moment(date); };
    var areDatesSame = function (firstDate, secondDate) { return moment(firstDate)
        .isSame(secondDate, 'date'); };
    var getTimeTableHeight = function (timeTableElementsMeta) { var _a; return (_a = timeTableElementsMeta.parentRect) === null || _a === void 0 ? void 0 : _a.call(timeTableElementsMeta).height; };
    var containsDSTChange = function (date) {
        var momentDate = moment(date);
        momentDate.startOf('day');
        var isStartDST = momentDate.isDST();
        momentDate.endOf('day');
        var isEndDst = momentDate.isDST();
        return (isStartDST && !isEndDst) || (!isStartDST && isEndDst);
    };

    var subtractSecond = function (date) { return moment(date).subtract(1, 'second').toDate(); };
    var dayScale = function (currentDate, firstDayOfWeek, dayCount, excluded) {
        if (excluded === void 0) { excluded = []; }
        var result = [];
        var date = firstDayOfWeek !== undefined
            ? moment(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded))
            : moment(currentDate);
        for (var index = 0; index < dayCount; index += 1) {
            if (excluded.findIndex(function (item) { return item === date.day(); }) === -1) {
                result.push(date.toDate());
            }
            date.add(1, 'days');
        }
        return result;
    };
    var timeScale = function (currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays) {
        var result = [];
        var startDateOfView = firstDayOfWeek !== undefined
            ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays)
            : currentDate;
        var isDSTChange = containsDSTChange(startDateOfView);
        var validDate = moment(startDateOfView);
        if (isDSTChange) {
            validDate.subtract(1, 'day');
        }
        var left = moment(validDate)
            .startOf('day')
            .add(startDayHour, 'hour');
        var right = moment(validDate)
            .startOf('day')
            .add(endDayHour, 'hour');
        while (left.isBefore(right)) {
            var startDate = left.toDate();
            left.add(cellDuration, 'minutes');
            result.push({ start: startDate, end: left.toDate() });
        }
        var timeScaleLastIndex = result.length - 1;
        if (isMidnight(result[timeScaleLastIndex].end)) {
            result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end);
        }
        return result;
    };
    var availableViews = function (views, viewName, viewDisplayName) {
        if (!views)
            return [{ name: viewName, displayName: viewDisplayName }];
        if (views.findIndex(function (view) { return viewName === view.name; }) === -1) {
            var nextViews = views.slice();
            nextViews.push({ name: viewName, displayName: viewDisplayName });
            return nextViews;
        }
        return views;
    };
    var viewCellsData = function (currentDate, firstDayOfWeek, dayCount, excludedDays, startDayHour, endDayHour, cellDuration, currTime) {
        var days = dayScale(currentDate, firstDayOfWeek, dayCount, excludedDays);
        var times = timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays);
        var currentTime = moment(currTime);
        return times.reduce(function (cellsAcc, time) {
            var start = moment(time.start);
            var end = moment(time.end);
            var rowCells = days.reduce(function (rowAcc, day) {
                var startDate = moment(day).hours(start.hours()).minutes(start.minutes()).toDate();
                var endDate = moment(day).hours(end.hours()).minutes(end.minutes()).toDate();
                var today = currentTime.isSame(startDate, 'day');
                rowAcc.push({ startDate: startDate, endDate: endDate, today: today });
                return rowAcc;
            }, []);
            cellsAcc.push(rowCells);
            return cellsAcc;
        }, []);
    };
    var timeCellsData = function (cellsData, startDayHour, endDayHour, cellDuration, currentTime) {
        var firstViewDate = cellsData[0][0].startDate;
        if (!containsDSTChange(firstViewDate)) {
            return cellsData;
        }
        var nextDay = moment(firstViewDate)
            .add(1, 'day')
            .toDate();
        var validCellsData = viewCellsData(nextDay, undefined, 1, [], startDayHour, endDayHour, cellDuration, currentTime);
        return validCellsData;
    };
    var allDayCells = function (viewCells) { return [viewCells[0].map(function (cell) { return ({
            startDate: moment(cell.startDate).startOf('day').toDate(),
            endDate: moment(cell.startDate).add(1, 'day').startOf('day').toDate(),
            groupingInfo: cell.groupingInfo,
            endOfGroup: cell.endOfGroup,
        }); })]; };
    var startViewDate = function (viewCells) { return moment(viewCells[0][0].startDate).toDate(); };
    var endViewDate = function (viewCells) {
        var lastRowIndex = viewCells.length - 1;
        var lastCellIndex = viewCells[lastRowIndex].length - 1;
        return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate);
    };

    var MAX_WIDTH = 1;
    var INDIRECT_CHILD_LEFT_OFFSET = 0.05;
    var isAllDayElementsMetaActual = function (viewCellsData, allDayElementsMeta, groupOrientation, groupCount) {
        var numberOfRows = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 1 : groupCount;
        return isElementsMetaActual(viewCellsData, allDayElementsMeta, numberOfRows);
    };
    var isTimeTableElementsMetaActual = function (viewCellsData, timeTableElementsMeta) { return isElementsMetaActual(viewCellsData, timeTableElementsMeta, viewCellsData.length); };
    var isElementsMetaActual = function (viewCellsData, elementsMeta, numberOfRows) {
        if (!(elementsMeta === null || elementsMeta === void 0 ? void 0 : elementsMeta.getCellRects)) {
            return false;
        }
        var tableSize = numberOfRows * viewCellsData[0].length;
        return tableSize === elementsMeta.getCellRects.length;
    };
    var appointmentHeightType = function (appointment, cellDuration) {
        var durationRatio = appointment.end.clone().diff(appointment.start, 'minutes') / cellDuration;
        if (durationRatio === 1)
            return 'middle';
        if (durationRatio > 1)
            return 'long';
        return 'short';
    };
    var horizontalRectCalculator = function (appointment, viewMetaData, _a) {
        var getRectByAppointment = _a.rectByDates, multiline = _a.multiline, _b = _a.rectByDatesMeta, cellElementsMeta = _b.cellElementsMeta, viewCellsData = _b.viewCellsData;
        var _c = getRectByAppointment(appointment, viewMetaData, {
            multiline: multiline,
            cellElementsMeta: cellElementsMeta,
            viewCellsData: viewCellsData,
        }), top = _c.top, left = _c.left, width = _c.width, height = _c.height, parentWidth = _c.parentWidth;
        return {
            resources: appointment.resources,
            top: top + ((height / appointment.reduceValue) * appointment.offset),
            height: height / appointment.reduceValue,
            left: toPercentage(left, parentWidth),
            width: toPercentage(width, parentWidth),
            dataItem: appointment.dataItem,
            fromPrev: appointment.fromPrev,
            toNext: appointment.toNext,
            type: HORIZONTAL_TYPE,
            key: appointment.key,
        };
    };
    var verticalRectCalculator = function (appointment, viewMetaData, _a) {
        var getRectByAppointment = _a.rectByDates, multiline = _a.multiline, _b = _a.rectByDatesMeta, viewCellsData = _b.viewCellsData, cellDuration = _b.cellDuration, cellElementsMeta = _b.cellElementsMeta, excludedDays = _b.excludedDays;
        var _c = getRectByAppointment(appointment, viewMetaData, {
            multiline: multiline,
            viewCellsData: viewCellsData,
            cellDuration: cellDuration,
            excludedDays: excludedDays,
            cellElementsMeta: cellElementsMeta,
        }), top = _c.top, left = _c.left, width = _c.width, height = _c.height, parentWidth = _c.parentWidth;
        var offset = appointment.offset, relativeWidth = appointment.width, relativeLeft = appointment.left;
        var widthMultiplier = (relativeWidth * 5 / 3 + relativeLeft) <= 1 ? 5 / 3 : 1;
        var validWidth = widthMultiplier === 5 / 3
            ? widthMultiplier * relativeWidth : relativeWidth + 0.02;
        if (validWidth + relativeLeft > 1) {
            validWidth = 1 - relativeLeft;
        }
        return {
            resources: appointment.resources,
            top: top,
            height: height,
            left: toPercentage(left + relativeLeft * width, parentWidth),
            width: toPercentage(validWidth * width, parentWidth),
            dataItem: appointment.dataItem,
            fromPrev: appointment.fromPrev,
            toNext: appointment.toNext,
            durationType: appointmentHeightType(appointment, cellDuration),
            type: VERTICAL_TYPE,
            offset: offset,
            key: appointment.key,
        };
    };
    var oldVerticalRectCalculator = function (appointment, viewMetaData, _a) {
        var getRectByAppointment = _a.rectByDates, multiline = _a.multiline, _b = _a.rectByDatesMeta, viewCellsData = _b.viewCellsData, cellDuration = _b.cellDuration, cellElementsMeta = _b.cellElementsMeta, excludedDays = _b.excludedDays, placeAppointmentsNextToEachOther = _b.placeAppointmentsNextToEachOther;
        var _c = getRectByAppointment(appointment, viewMetaData, {
            multiline: multiline,
            viewCellsData: viewCellsData,
            cellDuration: cellDuration,
            excludedDays: excludedDays,
            cellElementsMeta: cellElementsMeta,
            placeAppointmentsNextToEachOther: placeAppointmentsNextToEachOther,
        }), top = _c.top, left = _c.left, width = _c.width, height = _c.height, parentWidth = _c.parentWidth;
        var widthInPx = width / appointment.reduceValue;
        return {
            resources: appointment.resources,
            top: top,
            height: height,
            left: toPercentage(left + (widthInPx * appointment.offset), parentWidth),
            width: toPercentage(widthInPx, parentWidth),
            dataItem: appointment.dataItem,
            fromPrev: appointment.fromPrev,
            toNext: appointment.toNext,
            durationType: appointmentHeightType(appointment, cellDuration),
            type: VERTICAL_TYPE,
            key: appointment.key,
        };
    };
    var compareByDay = function (first, second) {
        if (first.start.isBefore(second.start, 'day'))
            return -1;
        if (first.start.isAfter(second.start, 'day'))
            return 1;
        return 0;
    };
    var compareByAllDay = function (first, second) {
        if (first.allDay && !second.allDay)
            return -1;
        if (!first.allDay && second.allDay)
            return 1;
        return 0;
    };
    var compareByTime = function (first, second) {
        if (first.start.isBefore(second.start))
            return -1;
        if (first.start.isAfter(second.start))
            return 1;
        if (first.end.isBefore(second.end))
            return 1;
        if (first.end.isAfter(second.end))
            return -1;
        return 0;
    };
    var sortAppointments = function (appointments) { return appointments
        .slice().sort(function (a, b) { return compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b); }); };
    var byDayPredicate = function (boundary, date) { return (boundary.isSameOrAfter(date, 'day')
        && !boundary.isSame(boundary.clone().startOf('day'))); };
    var findOverlappedAppointments = function (sortedAppointments, byDay) {
        if (byDay === void 0) { byDay = false; }
        var appointments = sortedAppointments.slice();
        var groups = [];
        var totalIndex = 0;
        while (totalIndex < appointments.length) {
            groups.push([]);
            var current = appointments[totalIndex];
            var currentGroup = groups[groups.length - 1];
            var next = appointments[totalIndex + 1];
            var maxBoundary = current.end;
            currentGroup.push(current);
            totalIndex += 1;
            while (next && (maxBoundary.isAfter(next.start)
                || (byDay && byDayPredicate(maxBoundary, next.start)))) {
                currentGroup.push(next);
                if (maxBoundary.isBefore(next.end))
                    maxBoundary = next.end;
                totalIndex += 1;
                next = appointments[totalIndex];
            }
        }
        return groups;
    };
    var isMidnight$1 = function (date) { return date.isSame(date.clone().startOf('day')); };
    var maxBoundaryPredicate = function (maxBoundary, startDate) { return ((maxBoundary.isBefore(startDate, 'day'))
        || (isMidnight$1(maxBoundary) && maxBoundary.isSame(startDate, 'day'))); };
    var calculateAppointmentOffsets = function (groups, byDay) {
        if (byDay === void 0) { byDay = false; }
        return groups.map(function (items) {
            var offset = 0;
            var reduceValue = 1;
            var appointments = items.map(function (appointment) { return (__assign({}, appointment)); });
            var groupLength = appointments.length;
            for (var startIndex = 0; startIndex < groupLength; startIndex += 1) {
                var appointment = appointments[startIndex];
                if (appointment.offset === undefined) {
                    var maxBoundary = appointment.end;
                    appointment.offset = offset;
                    for (var index = startIndex + 1; index < groupLength; index += 1) {
                        if (appointments[index].offset === undefined) {
                            if ((!byDay && maxBoundary.isSameOrBefore(appointments[index].start))
                                || (byDay && maxBoundaryPredicate(maxBoundary, appointments[index].start))) {
                                maxBoundary = appointments[index].end;
                                appointments[index].offset = offset;
                            }
                        }
                    }
                    offset += 1;
                    if (reduceValue < offset)
                        reduceValue = offset;
                }
            }
            return { items: appointments, reduceValue: reduceValue };
        });
    };
    var unwrapAppointmentForest = function (appointmentForests) {
        var forestUnwrapped = appointmentForests.map(function (_a) {
            var items = _a.items, reduceValue = _a.reduceValue;
            return ({
                reduceValue: reduceValue,
                items: items.map(function (_a) {
                    var data = _a.data;
                    return (__assign({}, data));
                }),
            });
        });
        return unwrapGroups(forestUnwrapped);
    };
    var unwrapGroups = function (groups) { return groups.reduce(function (acc, _a) {
        var items = _a.items, reduceValue = _a.reduceValue;
        acc.push.apply(acc, __spread(items.map(function (_a) {
            var start = _a.start, end = _a.end, dataItem = _a.dataItem, offset = _a.offset, resources = _a.resources, key = _a.key, restProps = __rest(_a, ["start", "end", "dataItem", "offset", "resources", "key"]);
            return (__assign({ start: start, end: end, dataItem: dataItem, offset: offset, reduceValue: reduceValue, resources: resources, fromPrev: moment(start).diff(dataItem.startDate, 'minutes') > 1, toNext: moment(dataItem.endDate).diff(end, 'minutes') > 1, key: key }, restProps));
        })));
        return acc;
    }, []); };
    var intervalIncludes = function (intervalStart, intervalEnd, date) { return date
        .isBetween(intervalStart, intervalEnd, undefined, '[)'); };
    var createAppointmentForest = function (appointmentGroups, cellDuration) { return appointmentGroups.map(function (appointmentGroup) {
        var items = appointmentGroup.items;
        var nextItems;
        var roots;
        if (items.length === 1) {
            nextItems = [{
                    data: items[0], children: [], treeDepth: 0, isDirectChild: false, hasDirectChild: false,
                }];
            roots = [0];
        }
        else {
            var _a = visitRoots(items, cellDuration), appointments = _a.appointments, appointmentTreeRoots = _a.roots;
            nextItems = appointments;
            roots = appointmentTreeRoots;
        }
        return __assign(__assign({}, appointmentGroup), { items: nextItems, roots: roots });
    }); };
    var visitRoots = function (appointmentItems, cellDuration) {
        var appointmentNodes = appointmentItems.map(function (props) { return ({
            data: props,
        }); });
        var roots = appointmentNodes.reduce(function (acc, appointment, appointmentIndex) {
            var appointmentOffset = appointment.data.offset;
            if (appointmentOffset === 0) {
                if (appointmentIndex + 1 === appointmentNodes.length) {
                    appointment.children = [];
                    appointment.hasDirectChild = false;
                    appointment.treeDepth = 0;
                }
                else {
                    appointment.treeDepth = visitAllChildren(appointmentNodes, appointmentIndex, cellDuration, 0);
                }
                appointment.parent = undefined;
                appointment.isDirectChild = false;
                return __spread(acc, [appointmentIndex]);
            }
            return acc;
        }, []);
        return { appointments: appointmentNodes, roots: roots };
    };
    var visitChild = function (appointmentNodes, index, parentAppointmentIndex, cellDuration, isDirectChild, treeDepth) {
        var appointmentNode = appointmentNodes[index];
        appointmentNode.isDirectChild = isDirectChild;
        appointmentNode.parent = parentAppointmentIndex;
        var nextTreeDepth = treeDepth + 1;
        var end = appointmentNode.data.end;
        if (index === appointmentNodes.length - 1
            || end.isSameOrBefore(appointmentNodes[index + 1].data.start)) {
            appointmentNode.children = [];
            appointmentNode.treeDepth = 0;
            appointmentNode.hasDirectChild = false;
            return nextTreeDepth;
        }
        var calculatedTreeDepth = visitAllChildren(appointmentNodes, index, cellDuration, treeDepth);
        appointmentNode.treeDepth = calculatedTreeDepth;
        return calculatedTreeDepth + 1;
    };
    var visitAllChildren = function (appointmentNodes, appointmentIndex, cellDuration, treeDepth) {
        var appointment = appointmentNodes[appointmentIndex];
        var _a = appointment.data, end = _a.end, appointmentOffset = _a.offset, start = _a.start;
        var directChildTimeLimit = moment(start).add(cellDuration, 'minutes');
        var maxAppointmentTreeDepth = 0;
        var children = [];
        var nextChildIndex = appointmentIndex + 1;
        while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {
            var nextAppointment = appointmentNodes[nextChildIndex];
            var _b = nextAppointment.data, nextOffset = _b.offset, nextStart = _b.start;
            if (nextOffset === appointmentOffset + 1) {
                var isDirectChild = intervalIncludes(start, directChildTimeLimit, nextStart);
                var nextTreeDepth = visitChild(appointmentNodes, nextChildIndex, appointmentIndex, cellDuration, isDirectChild, treeDepth);
                if (maxAppointmentTreeDepth < nextTreeDepth) {
                    maxAppointmentTreeDepth = nextTreeDepth;
                }
                children.push(nextChildIndex);
            }
            nextChildIndex += 1;
        }
        appointment.hasDirectChild = children.length !== 0 && appointmentNodes[children[0]].isDirectChild;
        appointment.children = children;
        return maxAppointmentTreeDepth;
    };
    var isPossibleChild = function (appointments, possibleChildIndex, parentEnd, parentOffset) {
        var possibleChild = appointments[possibleChildIndex];
        return (possibleChildIndex < appointments.length
            && possibleChild.data.offset !== parentOffset
            && possibleChild.data.start.isBefore(parentEnd));
    };
    var findMaxReduceValue = function (appointmentGroups) { return appointmentGroups.reduce(function (maxReduceValue, group) {
        var currentReduceValue = group.reduceValue;
        return maxReduceValue > currentReduceValue ? maxReduceValue : currentReduceValue;
    }, 1); };
    var calculateAppointmentsMetaData = function (appointmentGroups, indirectChildLeftOffset) { return appointmentGroups.map(function (appointmentForest) {
        var items = appointmentForest.items, roots = appointmentForest.roots;
        var firstNode = items[0];
        return __assign(__assign({}, appointmentForest), { items: items.length === 1
                ? [__assign(__assign({}, firstNode), { data: __assign(__assign({}, firstNode.data), { left: 0, width: 1 }) })]
                : calculateRootsMetaData(items, roots, indirectChildLeftOffset) });
    }); };
    var calculateRootsMetaData = function (appointmentNodes, roots, indirectChildLeftOffset) {
        var appointments = appointmentNodes.map(function (props) { return (__assign({}, props)); });
        roots.forEach(function (appointmentIndex) {
            var appointment = appointments[appointmentIndex];
            var _a = calculateAppointmentLeftAndWidth(appointments, undefined, appointment, MAX_WIDTH, indirectChildLeftOffset, undefined), left = _a.left, width = _a.width;
            appointment.data.left = left;
            appointment.data.width = width;
            calculateChildrenMetaData(appointments, appointment, MAX_WIDTH, indirectChildLeftOffset);
        });
        return appointments;
    };
    var calculateChildMetaData = function (appointmentNodes, appointmentIndex, maxWidth, indirectChildLeftOffset) {
        var appointment = appointmentNodes[appointmentIndex];
        var _a = calculateAppointmentLeftAndWidth(appointmentNodes, undefined, appointment, maxWidth, indirectChildLeftOffset, undefined), left = _a.left, width = _a.width;
        appointment.data.left = left;
        appointment.data.width = width;
        calculateChildrenMetaData(appointmentNodes, appointment, maxWidth, indirectChildLeftOffset);
    };
    var calculateChildrenMetaData = function (appointmentNodes, appointmentNode, maxWidth, indirectChildLeftOffset) {
        appointmentNode.children.forEach(function (childIndex) {
            calculateChildMetaData(appointmentNodes, childIndex, maxWidth, indirectChildLeftOffset);
        });
    };
    var calculateAppointmentLeftAndWidth = function (appointmentNodes, blocks, appointmentNode, maxRight, indirectChildLeftOffset, defaultLeft) {
        var _a;
        var _b = appointmentNode, hasDirectChild = _b.hasDirectChild, treeDepth = _b.treeDepth, isDirectChild = _b.isDirectChild, parentIndex = _b.parent, children = _b.children, blockIndex = _b.blockIndex;
        var firstChild = appointmentNodes[children[0]];
        var firstChildBlockIndex = (_a = firstChild) === null || _a === void 0 ? void 0 : _a.blockIndex;
        var hasDirectChildAndInSameBlock = hasDirectChild
            && (firstChildBlockIndex === undefined || (blockIndex === firstChildBlockIndex
                || blocks[firstChildBlockIndex].includedInto === blockIndex
                || maxRight === 1));
        if (parentIndex === undefined) {
            return ({
                width: hasDirectChildAndInSameBlock ? maxRight / (treeDepth + 1) : maxRight,
                left: 0,
            });
        }
        var parent = appointmentNodes[parentIndex];
        var _c = parent.data, parentWidth = _c.width, parentLeft = _c.left;
        var calculatedLeft = isDirectChild
            ? parentLeft + parentWidth : parentLeft + indirectChildLeftOffset;
        var left = defaultLeft !== undefined ? Math.max(defaultLeft, calculatedLeft) : calculatedLeft;
        var unoccupiedSpace = maxRight - left;
        return ({
            width: hasDirectChildAndInSameBlock ? unoccupiedSpace / (treeDepth + 1) : unoccupiedSpace,
            left: left,
        });
    };
    var prepareToGroupIntoBlocks = function (appointments) { return appointments.map(function (appointmentForest) {
        var nodes = appointmentForest.items;
        var appointmentNodes = nodes.map(function (props) { return (__assign({}, props)); });
        appointmentNodes.forEach(function (appointmentNode, index) {
            if (index === 0) {
                appointmentNode.overlappingSubTreeRoots = [];
                return;
            }
            var overlappingSubTreeRoots = [];
            var _a = appointmentNode.data, appointmentOffset = _a.offset, end = _a.end;
            var nextChildIndex = index + 1;
            var currentBlockEnd;
            while (isPossibleChild(appointmentNodes, nextChildIndex, end, appointmentOffset)) {
                var nextAppointment = appointmentNodes[nextChildIndex];
                if (nextAppointment.data.offset < appointmentOffset
                    && nextAppointment.maxOffset === undefined) {
                    nextAppointment.maxOffset = appointmentOffset;
                }
                var previousSubTreeRoot = overlappingSubTreeRoots.length > 0
                    ? appointmentNodes[overlappingSubTreeRoots[overlappingSubTreeRoots.length - 1]]
                    : undefined;
                if (isOverlappingSubTreeRoot(appointmentNode, nextAppointment, previousSubTreeRoot, currentBlockEnd)) {
                    overlappingSubTreeRoots.push(nextChildIndex);
                    nextAppointment.overlappingSubTreeRoot = true;
                    var maxChildDate = findChildrenMaxEndDate(appointmentNodes, nextAppointment);
                    if (!currentBlockEnd || currentBlockEnd.isBefore(maxChildDate)) {
                        currentBlockEnd = maxChildDate;
                    }
                }
                nextChildIndex += 1;
            }
            appointmentNode.overlappingSubTreeRoots = overlappingSubTreeRoots;
        });
        return __assign(__assign({}, appointmentForest), { items: appointmentNodes });
    }); };
    var isOverlappingSubTreeRoot = function (appointmentNode, nextAppointment, previousSubTreeRoot, previousEndDate) {
        var overlappingSubTreeRoot = nextAppointment.overlappingSubTreeRoot, maxOffset = nextAppointment.maxOffset, nextData = nextAppointment.data;
        var nextOffset = nextData.offset, nextStart = nextData.start;
        var offset = appointmentNode.data.offset;
        return (nextOffset < offset
            && !overlappingSubTreeRoot
            && (maxOffset === undefined || maxOffset >= offset)
            && (!previousSubTreeRoot
                || (previousSubTreeRoot.data.offset >= nextOffset
                    && nextStart.isSameOrAfter(previousEndDate))));
    };
    var findChildrenMaxEndDate = function (appointmentNodes, appointmentNode) {
        var children = appointmentNode.children, data = appointmentNode.data;
        var end = data.end;
        var maxDate = children.reduce(function (currentMaxDate, childIndex) {
            var child = appointmentNodes[childIndex];
            var maxChildrenDate = findChildrenMaxEndDate(appointmentNodes, child);
            if (maxChildrenDate.isAfter(currentMaxDate)) {
                return maxChildrenDate;
            }
            return currentMaxDate;
        }, end);
        return maxDate;
    };
    var groupAppointmentsIntoBlocks = function (appointmentForests) { return appointmentForests.map(function (appointmentForest) {
        var items = appointmentForest.items, reduceValue = appointmentForest.reduceValue;
        var _a = items.reduce(function (acc, appointment, index) {
            var blocks = acc.blocks.slice();
            var treeDepth = appointment.treeDepth, data = appointment.data, overlappingSubTreeRoots = appointment.overlappingSubTreeRoots;
            var offset = data.offset, start = data.start, end = data.end;
            var blockIndex = findBlockIndexByAppointment(blocks, appointment);
            if (blockIndex < 0) {
                blocks.push({
                    start: start, end: end,
                    minOffset: offset, maxOffset: offset + treeDepth,
                    size: treeDepth + 1, items: [], endForChildren: end,
                });
                blockIndex = blocks.length - 1;
            }
            blocks[blockIndex].items.push(index);
            overlappingSubTreeRoots.forEach(function (subTreeRootIndex) {
                var subTreeRoot = items[subTreeRootIndex];
                var subTreeRootData = subTreeRoot.data;
                blocks.push({
                    start: subTreeRootData.start,
                    end: end,
                    minOffset: subTreeRootData.offset, maxOffset: offset - 1,
                    size: calculateBlockSizeByEndDate(items, subTreeRoot, end), items: [],
                    endForChildren: subTreeRootData.end,
                });
            });
            var appointmentInBlock = __assign(__assign({}, appointment), { blockIndex: blockIndex });
            return {
                blocks: blocks,
                appointments: __spread(acc.appointments, [appointmentInBlock]),
            };
        }, {
            blocks: [{
                    start: items[0].data.start,
                    end: items[0].data.end,
                    minOffset: 0,
                    maxOffset: reduceValue - 1,
                    size: reduceValue,
                    items: [],
                    endForChildren: items[0].data.end,
                }],
            appointments: [],
        }), nextBlocks = _a.blocks, appointments = _a.appointments;
        return {
            blocks: nextBlocks,
            appointmentForest: __assign(__assign({}, appointmentForest), { items: appointments }),
        };
    }); };
    var calculateBlockSizeByEndDate = function (appointmentNodes, subTreeRoot, blockEndDate) {
        var children = subTreeRoot.children, data = subTreeRoot.data;
        var start = data.start;
        if (children.length === 0) {
            if (blockEndDate.isAfter(start)) {
                return 1;
            }
            return 0;
        }
        var maxSize = Math.max.apply(Math, __spread(children.map(function (childIndex) { return calculateBlockSizeByEndDate(appointmentNodes, appointmentNodes[childIndex], blockEndDate); })));
        if (blockEndDate.isSameOrBefore(start) && maxSize === 0) {
            return 0;
        }
        return maxSize + 1;
    };
    var findBlockIndexByAppointment = function (blocks, appointment) {
        var _a = appointment.data, start = _a.start, offset = _a.offset;
        var blockIndex = blocks.length - 1;
        while (blockIndex >= 0) {
            var currentBlock = blocks[blockIndex];
            if (intervalIncludes(currentBlock.start, currentBlock.end, start)
                && offset >= currentBlock.minOffset && offset <= currentBlock.maxOffset &&
                (!appointment.overlappingSubTreeRoot ||
                    appointment.overlappingSubTreeRoot && !currentBlock.items.length)) {
                break;
            }
            blockIndex -= 1;
        }
        return blockIndex;
    };
    var findIncludedBlocks = function (groupedIntoBlocks) {
        return groupedIntoBlocks.map(function (_a) {
            var blocks = _a.blocks, appointmentForest = _a.appointmentForest;
            var nextBlocks = blocks.map(function (props) { return (__assign({}, props)); });
            nextBlocks.forEach(function (block, blockIndex) {
                block.includedBlocks = [];
                for (var currentBlockIndex = blockIndex + 1; currentBlockIndex < nextBlocks.length; currentBlockIndex += 1) {
                    var currentBlock = nextBlocks[currentBlockIndex];
                    if (isIncludedBlock(block, currentBlock)) {
                        block.includedBlocks.push(currentBlockIndex);
                        currentBlock.includedInto = blockIndex;
                    }
                }
            });
            return {
                blocks: nextBlocks,
                appointmentForest: appointmentForest,
            };
        });
    };
    var isIncludedBlock = function (block, possibleIncludedBlock) {
        var start = block.start, end = block.end, minOffset = block.minOffset, maxOffset = block.maxOffset;
        var possibleIncludedStart = possibleIncludedBlock.start, possibleIncludedEnd = possibleIncludedBlock.end, possibleMinOffset = possibleIncludedBlock.minOffset, possibleMaxOffset = possibleIncludedBlock.maxOffset;
        return intervalIncludes(start, end, possibleIncludedStart)
            && intervalIncludes(start, end, possibleIncludedEnd)
            && possibleMaxOffset <= maxOffset && possibleMinOffset >= minOffset;
    };
    var findChildBlocks = function (groupedIntoBlocks) {
        return groupedIntoBlocks.map(function (_a) {
            var blocks = _a.blocks, appointmentForest = _a.appointmentForest;
            var nextBlocks = blocks.map(function (props) { return (__assign({}, props)); });
            nextBlocks.forEach(function (block, index) {
                block.children = [];
                for (var currentIndex = index + 1; currentIndex < nextBlocks.length; currentIndex += 1) {
                    var nextBlock = nextBlocks[currentIndex];
                    if (isChildBlock(block, nextBlock)) {
                        block.children.push(currentIndex);
                        nextBlock.parent = index;
                    }
                }
                return block;
            });
            return {
                appointmentForest: appointmentForest,
                blocks: nextBlocks,
            };
        });
    };
    var isChildBlock = function (block, possibleChildBlock) {
        var start = block.start, endForChildren = block.endForChildren, minOffset = block.minOffset, includedInto = block.includedInto;
        var childStart = possibleChildBlock.start, childIncludedInto = possibleChildBlock.includedInto, childMaxOffset = possibleChildBlock.maxOffset;
        return intervalIncludes(start, endForChildren, childStart)
            && childMaxOffset + 1 === minOffset
            && (childIncludedInto === undefined
                || childIncludedInto === includedInto);
    };
    var adjustByBlocks = function (groupedIntoBlocks, indirectChildLeftOffset) {
        var updatedBlocks = groupedIntoBlocks.map(function (_a) {
            var blocks = _a.blocks, appointmentForest = _a.appointmentForest;
            var dimensionsCalculated = calculateBlocksDimensions(blocks, appointmentForest.items);
            return {
                blocks: alignBlocksWithPrevious(dimensionsCalculated, appointmentForest.items),
                appointmentForest: appointmentForest,
            };
        });
        var adjustedByBlocks = updatedBlocks.map(function (_a) {
            var blocks = _a.blocks, appointmentForest = _a.appointmentForest;
            return __assign(__assign({}, appointmentForest), { items: adjustAppointmentsByBlocks(appointmentForest.items, blocks, indirectChildLeftOffset) });
        });
        return adjustedByBlocks;
    };
    var calculateBlocksDimensions = function (blocks, appointments) { return updateBlocksProportions(calculateBlocksLeftLimit(calculateBlocksTotalSize(blocks), appointments)); };
    var alignBlocksWithPrevious = function (blocks, appointments) {
        var nextBlocks = blocks.map(function (_a) {
            var right = _a.right, restProps = __rest(_a, ["right"]);
            return (__assign({}, restProps));
        });
        var leftLimitCalculated = calculateBlocksLeftLimit(updateBlocksLeft(nextBlocks, appointments), appointments);
        return updateBlocksProportions(leftLimitCalculated);
    };
    var adjustAppointmentsByBlocks = function (appointments, blocks, indirectChildLeftOffset) {
        var nextAppointments = appointments.map(function (props) { return (__assign({}, props)); });
        var nextBlocks = blocks.map(function (props) { return (__assign({}, props)); });
        nextBlocks.forEach(function (block, index) {
            if (index !== 0) {
                var items = block.items, blockLeft = block.left, right = block.right, children_1 = block.children;
                var maxRight_1 = calculateIncludedBlockMaxRight(nextBlocks, block);
                var finalMaxRight_1 = maxRight_1 * right;
                var defaultLeft_1 = blockLeft * maxRight_1;
                items.forEach(function (appointmentIndex, itemIndex) {
                    var appointment = nextAppointments[appointmentIndex];
                    if (itemIndex === 0) {
                        var _a = calculateAppointmentLeftAndWidth(nextAppointments, nextBlocks, appointment, finalMaxRight_1, indirectChildLeftOffset, defaultLeft_1), left_1 = _a.left, width = _a.width;
                        appointment.data.left = left_1;
                        appointment.data.width = width;
                        if (defaultLeft_1 !== left_1) {
                            children_1.forEach(function (childIndex) {
                                redistributeChildBlocks(nextBlocks, childIndex, left_1 / maxRight_1);
                            });
                        }
                    }
                    else {
                        var _b = calculateAppointmentLeftAndWidth(nextAppointments, nextBlocks, appointment, finalMaxRight_1, indirectChildLeftOffset, undefined), left = _b.left, width = _b.width;
                        appointment.data.left = left;
                        appointment.data.width = width;
                    }
                });
            }
        });
        blocks[0].items.forEach(function (appointmentIndex) {
            var appointment = nextAppointments[appointmentIndex];
            var _a = calculateAppointmentLeftAndWidth(nextAppointments, blocks, appointment, 1, indirectChildLeftOffset, undefined), left = _a.left, width = _a.width;
            appointment.data.left = left;
            appointment.data.width = width;
        });
        return nextAppointments;
    };
    var redistributeChildBlocks = function (blocks, blockIndex, right) {
        var block = blocks[blockIndex];
        var leftOffset = block.leftOffset, size = block.size, leftLimit = block.leftLimit, children = block.children;
        block.right = right;
        var width = size + leftOffset;
        var relativeWidth = right - leftLimit;
        var left = right - relativeWidth * size / width;
        block.left = left;
        children.forEach(function (childIndex) {
            redistributeChildBlocks(blocks, childIndex, left);
        });
    };
    var calculateIncludedBlockMaxRight = function (blocks, includedBlock) {
        var includedIntoIndex = includedBlock.includedInto;
        if (includedIntoIndex === undefined) {
            return 1;
        }
        var includedInto = blocks[includedIntoIndex];
        var currentMaxRight = includedInto.right;
        return currentMaxRight * calculateIncludedBlockMaxRight(blocks, includedInto);
    };
    var calculateBlocksTotalSize = function (blocks) {
        var result = blocks.map(function (block) {
            var totalSize = calculateSingleBlockTotalSize(blocks, block);
            return __assign(__assign({}, block), { totalSize: totalSize, leftOffset: totalSize - block.size });
        });
        return result;
    };
    var calculateSingleBlockTotalSize = function (blocks, block) {
        var children = block.children, size = block.size;
        if (children.length === 0) {
            return size;
        }
        return Math.max.apply(Math, __spread(children.map(function (childIndex) { return calculateSingleBlockTotalSize(blocks, blocks[childIndex]); }))) + size;
    };
    var calculateBlocksLeftLimit = function (blocks, appointments) { return blocks.map(function (block) {
        var leftLimit = calculateSingleBlockLeftLimit(blocks, appointments, block);
        return __assign(__assign({}, block), { leftLimit: leftLimit });
    }); };
    var calculateSingleBlockLeftLimit = function (blocks, appointments, block) {
        var _a = block, children = _a.children, items = _a.items, left = _a.left;
        if (children.length === 0) {
            return left !== undefined
                ? Math.min(left, appointments[items[0]].data.left)
                : appointments[items[0]].data.left;
        }
        return Math.min.apply(Math, __spread(children.map(function (childIndex) { return calculateSingleBlockLeftLimit(blocks, appointments, blocks[childIndex]); })));
    };
    var updateBlocksProportions = function (blocks) {
        var nextBlocks = blocks.map(function (props) { return (__assign({}, props)); });
        nextBlocks.forEach(function (block) {
            var parentIndex = block.parent, leftLimit = block.leftLimit, leftOffset = block.leftOffset, totalSize = block.totalSize;
            if (parentIndex === undefined) {
                block.right = 1;
                block.left = (1 - leftLimit) * leftOffset / totalSize + leftLimit;
                return;
            }
            var parent = nextBlocks[parentIndex];
            var _a = parent, parentLeft = _a.left, parentTotalSize = _a.totalSize;
            block.totalSize = parentTotalSize;
            block.right = parentLeft;
            block.left = (1 - leftLimit) * leftOffset / parentTotalSize + leftLimit;
        });
        return nextBlocks;
    };
    var updateBlocksLeft = function (blocks, appointments) { return blocks.map(function (block) {
        var items = block.items, left = block.left;
        var firstItem = appointments[items[0]];
        var firstItemParentIndex = firstItem.parent;
        if (firstItemParentIndex === undefined) {
            return block;
        }
        var firstItemParent = appointments[firstItemParentIndex];
        var parentBlock = blocks[firstItemParent.blockIndex];
        return __assign(__assign({}, block), { left: parentBlock.parent === undefined ? left : blocks[parentBlock.parent].left });
    }); };
    var createAndAdjustAppointmentForest = function (appointmentGroups, cellDuration) {
        var appointmentForest = createAppointmentForest(appointmentGroups, cellDuration);
        var indirectChildLeftOffset = Math.min(1 / findMaxReduceValue(appointmentForest), INDIRECT_CHILD_LEFT_OFFSET);
        var baseCalculated = calculateAppointmentsMetaData(appointmentForest, indirectChildLeftOffset);
        var preparedToGroupIntoBlocks = prepareToGroupIntoBlocks(baseCalculated);
        var groupedIntoBlocks = groupAppointmentsIntoBlocks(preparedToGroupIntoBlocks);
        var blocksWithIncluded = findIncludedBlocks(groupedIntoBlocks);
        var blocksWithParents = findChildBlocks(blocksWithIncluded);
        return adjustByBlocks(blocksWithParents, indirectChildLeftOffset);
    };
    var calculateRectByDateAndGroupIntervals = function (type, intervals, rectByDates, rectByDatesMeta, viewMetaData) {
        var growDirection = type.growDirection, multiline = type.multiline;
        var isHorizontal = growDirection === HORIZONTAL_TYPE;
        var sorted = intervals.map(sortAppointments);
        var grouped = sorted.reduce((function (acc, sortedGroup) { return __spread(acc, findOverlappedAppointments(sortedGroup, isHorizontal)); }), []);
        var cellDuration = rectByDatesMeta.cellDuration, placeAppointmentsNextToEachOther = rectByDatesMeta.placeAppointmentsNextToEachOther;
        var rectCalculator = isHorizontal
            ? horizontalRectCalculator
            : placeAppointmentsNextToEachOther ? oldVerticalRectCalculator : verticalRectCalculator;
        var groupsCalculated = calculateAppointmentOffsets(grouped, isHorizontal);
        var isAppointmentForestNeeded = !isHorizontal && !placeAppointmentsNextToEachOther;
        var appointmentForest;
        if (isAppointmentForestNeeded) {
            appointmentForest = createAndAdjustAppointmentForest(groupsCalculated, cellDuration);
        }
        var unwrappedAppointments = isAppointmentForestNeeded
            ? unwrapAppointmentForest(appointmentForest)
            : unwrapGroups(groupsCalculated);
        var rects = unwrappedAppointments.map(function (appointment) { return rectCalculator(appointment, viewMetaData, { rectByDates: rectByDates, multiline: multiline, rectByDatesMeta: rectByDatesMeta }); });
        return rects.sort(function (first, second) { return first.offset >= second.offset ? 1 : -1; });
    };

    var sliceAppointmentByDay = function (appointment, cellDuration) {
        var start = appointment.start, end = appointment.end, dataItem = appointment.dataItem, key = appointment.key;
        if (start.isSame(end, 'day'))
            return [appointment];
        var minDuration = cellDuration / 2;
        var isShortOnFirstDay = start.clone().endOf('day').diff(start, 'minutes') < minDuration;
        var isShortOnSecondDay = end.clone().diff(end.clone().startOf('day'), 'minutes') < minDuration;
        var firstAppointmentKey = addDateToKey(key, start);
        var secondAppointmentKey = addDateToKey(key, end);
        return [
            isShortOnFirstDay ? {
                start: start.clone().endOf('day').add(-minDuration, 'minutes'),
                end: start.clone().endOf('day'),
                dataItem: dataItem,
                key: firstAppointmentKey,
            } : {
                start: start,
                end: start.clone().endOf('day'),
                dataItem: dataItem,
                key: firstAppointmentKey,
            },
            isShortOnSecondDay ? {
                start: end.clone().startOf('day'),
                end: end.clone().startOf('day').add(minDuration, 'minutes'),
                dataItem: dataItem,
                key: secondAppointmentKey,
            } : {
                start: end.clone().startOf('day'),
                end: end, dataItem: dataItem,
                key: secondAppointmentKey,
            },
        ];
    };
    var dayBoundaryPredicate = function (appointment, leftBound, rightBound, excludedDays) {
        if (excludedDays === void 0) { excludedDays = []; }
        var dayStart = moment(leftBound);
        var dayEnd = moment(rightBound);
        var startDayTime = moment(appointment.start)
            .hour(dayStart.hour())
            .minutes(dayStart.minutes());
        var endDayTime = moment(appointment.start)
            .hour(dayEnd.hour())
            .minutes(dayEnd.minutes());
        if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd))
            return false;
        if (excludedDays.findIndex(function (day) { return day === moment(appointment.start).day(); }) !== -1)
            return false;
        return (appointment.end.isAfter(startDayTime)
            && appointment.start.isBefore(endDayTime));
    };
    var reduceAppointmentByDayBounds = function (appointment, leftBound, rightBound, cellDuration) {
        var dayStart = moment(leftBound);
        var dayEnd = moment(rightBound);
        var startDayTime = moment(appointment.start)
            .hour(dayStart.hour())
            .minutes(dayStart.minutes())
            .seconds(dayStart.seconds());
        var endDayTime = moment(appointment.start)
            .hour(dayEnd.hour())
            .minutes(dayEnd.minutes())
            .seconds(dayEnd.seconds());
        var minDuration = cellDuration / 2;
        var isShortOnFirstDay = endDayTime.clone().diff(appointment.start, 'minutes') < minDuration;
        var isShortOnSecondDay = appointment.end.clone().diff(startDayTime, 'minutes') < minDuration;
        if (isShortOnFirstDay) {
            return __assign(__assign({}, appointment), { start: endDayTime.clone().add(-minDuration, 'minutes'), end: endDayTime });
        }
        if (isShortOnSecondDay) {
            return __assign(__assign({}, appointment), { start: startDayTime, end: startDayTime.clone().add(minDuration, 'minutes') });
        }
        return __assign(__assign(__assign({}, appointment), (appointment.start.isSameOrBefore(startDayTime) ? { start: startDayTime } : null)), (appointment.end.isSameOrAfter(endDayTime) ? { end: endDayTime } : null));
    };
    var normalizeAppointmentDuration = function (appointment, cellDuration) {
        var minDuration = cellDuration / 2;
        var start = moment(appointment.start);
        var end = moment(appointment.end);
        if (end.diff(start, 'minutes') > minDuration) {
            return __assign(__assign({}, appointment), { start: start, end: end });
        }
        if (end.isSame(start.clone().add(minDuration, 'minutes'), 'day')) {
            return __assign(__assign({}, appointment), { start: start, end: start.clone().add(minDuration, 'minutes') });
        }
        return __assign(__assign({}, appointment), { start: start.clone().endOf('day').add(-minDuration, 'minutes'), end: start.clone().endOf('day') });
    };
    var getWeekVerticallyGroupedColumnIndex = function (viewCellsData, date) { return viewCellsData[0].findIndex(function (timeCell) { return moment(date).isSame(timeCell.startDate, 'date'); }); };
    var getWeekHorizontallyGroupedColumnIndex = function (viewCellsData, appointment, date) { return viewCellsData[0].findIndex(function (timeCell) {
        var isCorrectGroup = checkCellGroupingInfo(timeCell, appointment);
        return moment(date).isSame(timeCell.startDate, 'date') && isCorrectGroup;
    }); };
    var getWeekVerticallyGroupedRowIndex = function (viewCellsData, appointment, date, columnIndex, takePrev, groupCount) {
        var timeTableHeight = viewCellsData.length / groupCount;
        var timeTableRowIndex = getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);
        if (!viewCellsData[0][0].groupingInfo)
            return timeTableRowIndex;
        var isWrongCell = !checkCellGroupingInfo(viewCellsData[timeTableRowIndex][columnIndex], appointment);
        while (isWrongCell) {
            timeTableRowIndex += timeTableHeight;
            isWrongCell = !checkCellGroupingInfo(viewCellsData[timeTableRowIndex][columnIndex], appointment);
        }
        return timeTableRowIndex;
    };
    var getWeekHorizontallyGroupedRowIndex = function (viewCellsData, date, columnIndex, takePrev) { return viewCellsData.findIndex(function (timeCell) { return moment(date)
        .isBetween(timeCell[columnIndex].startDate, timeCell[columnIndex].endDate, 'seconds', takePrev ? '(]' : '[)'); }); };

    var calculateWeekDateIntervals = function (appointments, leftBound, rightBound, // startViewDate, endViewDate
    excludedDays, cellDuration) { return [
        appointments
            .map(function (appointment) { return normalizeAppointmentDuration(appointment, cellDuration); })
            .reduce(function (acc, appointment) {
            return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true));
        }, [])
            .reduce(function (acc, appointment) { return (__spread(acc, sliceAppointmentByDay(appointment, cellDuration))); }, [])
            .filter(function (appointment) { return dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays); })
            .map(function (appointment) { return reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration); }),
    ]; };

    var CELL_GAP_PX = 10;
    var CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;
    var CELL_BOUND_VERTICAL_OFFSET_PX = 4;
    var getVerticalCellIndexByAppointmentData = function (appointment, viewCellsData, viewMetaData, date, takePrev) {
        if (takePrev === void 0) { takePrev = false; }
        var groupOrientation = viewMetaData.groupOrientation, groupCount = viewMetaData.groupCount;
        var columnIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION
            ? getWeekVerticallyGroupedColumnIndex(viewCellsData, date)
            : getWeekHorizontallyGroupedColumnIndex(viewCellsData, appointment, date);
        var rowIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION
            ? getWeekVerticallyGroupedRowIndex(viewCellsData, appointment, date, columnIndex, takePrev, groupCount) : getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);
        var cellIndex = (rowIndex * viewCellsData[0].length) + columnIndex;
        return {
            index: cellIndex,
            startDate: viewCellsData[rowIndex][columnIndex].startDate,
        };
    };
    var getCellRect = function (date, appointment, viewCellsData, cellDuration, cellElementsMeta, takePrev, viewMetaData) {
        var _a = getVerticalCellIndexByAppointmentData(appointment, viewCellsData, viewMetaData, date, takePrev), cellIndex = _a.index, cellStartDate = _a.startDate;
        var _b = cellElementsMeta.getCellRects[cellIndex](), top = _b.top, left = _b.left, width = _b.width, cellHeight = _b.height;
        var timeOffset = moment(date).diff(cellStartDate, 'minutes');
        var topOffset = cellHeight * (timeOffset / cellDuration);
        var parentRect = cellElementsMeta.parentRect();
        return {
            top: top,
            left: left,
            width: width,
            topOffset: topOffset,
            parentRect: parentRect,
        };
    };
    var getVerticalRectByAppointmentData = function (appointment, viewMetaData, _a) {
        var viewCellsData = _a.viewCellsData, cellDuration = _a.cellDuration, cellElementsMeta = _a.cellElementsMeta, placeAppointmentsNextToEachOther = _a.placeAppointmentsNextToEachOther;
        var firstCellRect = getCellRect(appointment.start.toDate(), appointment, viewCellsData, cellDuration, cellElementsMeta, false, viewMetaData);
        var lastCellRect = getCellRect(appointment.end.toDate(), appointment, viewCellsData, cellDuration, cellElementsMeta, true, viewMetaData);
        var top = firstCellRect.top + firstCellRect.topOffset;
        var height = (lastCellRect.top + lastCellRect.topOffset) - top;
        return {
            width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,
            top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,
            left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,
            parentWidth: firstCellRect.parentRect.width,
            height: placeAppointmentsNextToEachOther ? height - CELL_BOUND_VERTICAL_OFFSET_PX : height,
        };
    };

    var allDayPredicate = function (appointment) { return (appointment.end.diff(appointment.start, 'hours') > 23
        || !!appointment.allDay); };
    var getAllDayCellIndexByAppointmentData = function (viewCellsData, viewMetaData, date, appointment, takePrev) {
        var currentDate = moment(date);
        var groupOrientation = viewMetaData.groupOrientation, groupCount = viewMetaData.groupCount;
        var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION
            ? getAllDayHorizontallyGroupedColumnIndex(viewCellsData, currentDate, appointment)
            : getAllDayVerticallyGroupedColumnIndex(viewCellsData, currentDate);
        var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION
            ? 0 : getAllDayVerticallyGroupedRowIndex(viewCellsData, appointment, groupCount);
        var cellIndex = rowIndex * viewCellsData[0].length + columnIndex;
        if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {
            cellIndex -= 1;
        }
        return cellIndex;
    };
    var getAllDayVerticallyGroupedColumnIndex = function (viewCellsData, date) { return viewCellsData[0].findIndex(function (timeCell) {
        return date.isSame(timeCell.startDate, 'date');
    }); };
    var getAllDayHorizontallyGroupedColumnIndex = function (viewCellsData, date, appointment) { return viewCellsData[0].findIndex(function (timeCell) { return (date.isSame(timeCell.startDate, 'date') && checkCellGroupingInfo(timeCell, appointment)); }); };
    var getAllDayVerticallyGroupedRowIndex = function (viewCellsData, appointment, groupCount) {
        var index = viewCellsData.findIndex(function (viewCellsDataRow) { return checkCellGroupingInfo(viewCellsDataRow[0], appointment); });
        return index * groupCount / viewCellsData.length;
    };
    var sliceAppointmentsByBoundaries = function (appointment, left, right, excludedDays) {
        if (excludedDays === void 0) { excludedDays = []; }
        var startDate = appointment.start.clone();
        var endDate = appointment.end.clone();
        var nextStart = startDate.clone();
        var nextEnd = endDate.clone();
        if (startDate.isBefore(left)) {
            nextStart = moment(left);
            nextStart.startOf('day');
        }
        if (endDate.isAfter(right)) {
            nextEnd = moment(right);
            nextEnd.endOf('day');
        }
        if (excludedDays.findIndex(function (day) { return day === startDate.day(); }) !== -1) {
            while (excludedDays.findIndex(function (day) { return day === nextStart.day(); }) !== -1
                && nextStart.isSameOrBefore(endDate, 'day')) {
                nextStart.add(1, 'days').startOf('day');
            }
        }
        if (excludedDays.findIndex(function (day) { return day === endDate.day(); }) !== -1) {
            while (excludedDays.findIndex(function (day) { return day === nextEnd.day(); }) !== -1
                && nextStart.isSameOrAfter(startDate, 'day')) {
                nextEnd.add(-1, 'days').endOf('day');
            }
        }
        return [__assign(__assign({}, appointment), { start: nextStart, end: nextEnd })];
    };
    var sliceAppointmentsByDays = function (appointment, excludedDays) {
        if (excludedDays === void 0) { excludedDays = []; }
        var startDate = appointment.start;
        var endDate = appointment.end;
        var nextStart = startDate.clone();
        var appointments = [];
        while (nextStart.isBefore(endDate)) {
            if (excludedDays.findIndex(function (day) { return day === nextStart.day(); }) === -1) {
                appointments.push(__assign(__assign({}, appointment), { start: nextStart, end: moment(nextStart).endOf('day') }));
            }
            nextStart = moment(nextStart).add(1, 'day');
        }
        return appointments;
    };

    var DEFAULT_RULE_OBJECT = {
        interval: 1,
    };
    var DAYS_OF_WEEK = {
        MONDAY: 0,
        TUESDAY: 1,
        WEDNESDAY: 2,
        THURSDAY: 3,
        FRIDAY: 4,
        SATURDAY: 5,
        SUNDAY: 6,
    };
    var RRULE_DAYS_OF_WEEK = [
        rrule.RRule.MO,
        rrule.RRule.TU,
        rrule.RRule.WE,
        rrule.RRule.TH,
        rrule.RRule.FR,
        rrule.RRule.SA,
        rrule.RRule.SU,
    ];
    var DAYS_IN_WEEK = 7;
    var DAYS_OF_WEEK_ARRAY = [
        DAYS_OF_WEEK.SUNDAY, DAYS_OF_WEEK.MONDAY, DAYS_OF_WEEK.TUESDAY, DAYS_OF_WEEK.WEDNESDAY,
        DAYS_OF_WEEK.THURSDAY, DAYS_OF_WEEK.FRIDAY, DAYS_OF_WEEK.SATURDAY,
    ];
    var MONTHS = {
        JANUARY: 1,
        FEBRUARY: 2,
        MARCH: 3,
        APRIL: 4,
        MAY: 5,
        JUNE: 6,
        JULY: 7,
        AUGUST: 8,
        SEPTEMBER: 9,
        OCTOBER: 10,
        NOVEMBER: 11,
        DECEMBER: 12,
    };
    var RRULE_REPEAT_TYPES = {
        YEARLY: rrule.RRule.YEARLY,
        MONTHLY: rrule.RRule.MONTHLY,
        WEEKLY: rrule.RRule.WEEKLY,
        DAILY: rrule.RRule.DAILY,
        HOURLY: rrule.RRule.HOURLY,
        MINUTELY: rrule.RRule.MINUTELY,
    };
    var REPEAT_TYPES = {
        DAILY: 'daily',
        WEEKLY: 'weekly',
        MONTHLY: 'monthly',
        YEARLY: 'yearly',
        NEVER: 'never',
    };
    var REPEAT_TYPES_ARRAY = [
        REPEAT_TYPES.DAILY, REPEAT_TYPES.WEEKLY, REPEAT_TYPES.MONTHLY, REPEAT_TYPES.YEARLY,
    ];
    var WEEK_NUMBER_LABELS = [
        'firstLabel', 'secondLabel', 'thirdLabel', 'fourthLabel', 'lastLabel',
    ];
    var END_REPEAT_RADIO_GROUP = 'endRepeat';
    var MONTHLY_RADIO_GROUP = 'monthlyRadioGroup';
    var YEARLY_RADIO_GROUP = 'yearlyRadioGroup';
    var TITLE_TEXT_EDITOR = 'titleTextEditor';
    var MULTILINE_TEXT_EDITOR = 'multilineTextEditor';
    var ORDINARY_TEXT_EDITOR = 'ordinaryTextEditor';
    var NUMBER_EDITOR = 'numberEditor';
    var TITLE = 'title';
    var ORDINARY_LABEL = 'ordinaryLabel';
    var SAVE_BUTTON = 'saveButton';
    var DELETE_BUTTON = 'deleteButton';
    var CANCEL_BUTTON = 'cancelButton';
    var OUTLINED_SELECT = 'outlinedSelect';
    var STANDARD_SELECT = 'standardSelect';
    var SUNDAY_DATE = new Date(2019, 7, 11);
    var MONDAY_DATE = new Date(2019, 7, 12);
    var TUESDAY_DATE = new Date(2019, 7, 13);
    var WEDNESDAY_DATE = new Date(2019, 7, 14);
    var THURSDAY_DATE = new Date(2019, 7, 15);
    var FRIDAY_DATE = new Date(2019, 7, 16);
    var SATURDAY_DATE = new Date(2019, 7, 17);
    var DAYS_OF_WEEK_DATES = [
        SUNDAY_DATE, MONDAY_DATE, TUESDAY_DATE, WEDNESDAY_DATE,
        THURSDAY_DATE, FRIDAY_DATE, SATURDAY_DATE,
    ];
    var JANUARY_DATE = new Date(2019, 0, 1);
    var FEBRUARY_DATE = new Date(2019, 1, 1);
    var MARCH_DATE = new Date(2019, 2, 1);
    var APRIL_DATE = new Date(2019, 3, 1);
    var MAY_DATE = new Date(2019, 4, 1);
    var JUNE_DATE = new Date(2019, 5, 1);
    var JULY_DATE = new Date(2019, 6, 1);
    var AUGUST_DATE = new Date(2019, 7, 1);
    var SEPTEMBER_DATE = new Date(2019, 8, 1);
    var OCTOBER_DATE = new Date(2019, 9, 1);
    var NOVEMBER_DATE = new Date(2019, 10, 1);
    var DECEMBER_DATE = new Date(2019, 11, 1);
    var MONTHS_DATES = [
        JANUARY_DATE, FEBRUARY_DATE, MARCH_DATE, APRIL_DATE, MAY_DATE, JUNE_DATE,
        JULY_DATE, AUGUST_DATE, SEPTEMBER_DATE, OCTOBER_DATE, NOVEMBER_DATE, DECEMBER_DATE,
    ];
    var FIRST_WEEK = 0;
    var SECOND_WEEK = 1;
    var THIRD_WEEK = 2;
    var FOURTH_WEEK = 3;
    var LAST_WEEK = 4;
    var BASIC_YEALY_COUNT = 5;
    var BASIC_MONTHLY_COUNT = 12;
    var BASIC_WEEKLY_COUNT = 13;
    var BASIC_DAILY_COUNT = 30;

    var sliceAppointmentByWeek = function (timeBounds, appointment, step) {
        var left = timeBounds.left, right = timeBounds.right;
        var pieces = [];
        var start = appointment.start, end = appointment.end, key = appointment.key, restFields = __rest(appointment, ["start", "end", "key"]);
        var apptStart = start;
        var apptEnd = end;
        if (apptStart.isBefore(left))
            apptStart = left.clone();
        if (apptEnd.isAfter(right))
            apptEnd = right.clone();
        var pieceFrom = apptStart.clone();
        var pieceTo = apptStart.clone();
        var i = 0;
        while (pieceTo.isBefore(apptEnd)) {
            var currentRightBound = left.clone().add(step * i, 'days').subtract(1, 'second');
            if (currentRightBound.isAfter(apptStart)) {
                pieceTo = apptStart.clone().add(step * i, 'days');
                if (pieceTo.isAfter(currentRightBound)) {
                    pieceTo = currentRightBound.clone();
                }
                if (pieceTo.isAfter(apptEnd)) {
                    pieceTo = apptEnd.clone();
                }
                if (!pieceFrom.isSameOrAfter(pieceTo)) {
                    pieces.push(__assign({ start: pieceFrom, end: pieceTo, key: addDateToKey(key, pieceFrom) }, restFields));
                    pieceFrom = pieceTo.clone().add(1, 'second');
                }
            }
            i += 1;
        }
        return pieces;
    };
    var getMonthCellIndexByAppointmentData = function (viewCellsData, viewMetaData, date, appointment, takePrev) {
        if (takePrev === void 0) { takePrev = false; }
        var groupOrientation = viewMetaData.groupOrientation, groupedByDate = viewMetaData.groupedByDate, groupCount = viewMetaData.groupCount;
        var startViewDate = moment(viewCellsData[0][0].startDate);
        var currentDate = moment(date);
        var dayNumber = currentDate.diff(startViewDate, 'days');
        if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {
            dayNumber -= 1;
        }
        var weekNumber = Math.floor(dayNumber / DAYS_IN_WEEK);
        var dayOfWeek = dayNumber % DAYS_IN_WEEK;
        var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION
            ? getMonthHorizontallyGroupedColumnIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupedByDate)
            : dayOfWeek;
        var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION
            ? weekNumber
            : getMonthVerticallyGroupedRowIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount);
        var totalCellIndex = rowIndex * viewCellsData[0].length + columnIndex;
        return totalCellIndex;
    };
    var getMonthHorizontallyGroupedColumnIndex = function (viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupByDate) {
        var columnIndex = -1;
        var currentColumnIndex = groupByDate ? dayOfWeek * groupCount : dayOfWeek;
        var cellsInGroupRow = groupByDate ? 1 : DAYS_IN_WEEK;
        while (columnIndex === -1) {
            var isCorrectCell = checkCellGroupingInfo(viewCellsData[weekNumber][currentColumnIndex], appointment);
            if (isCorrectCell) {
                columnIndex = currentColumnIndex;
            }
            currentColumnIndex += cellsInGroupRow;
        }
        return columnIndex;
    };
    var getMonthVerticallyGroupedRowIndex = function (viewCellsData, appointment, weekNumber, dayOfWeek, groupCount) {
        var rowsInOneGroup = viewCellsData.length / groupCount;
        var rowIndex = -1;
        var currentRowIndex = weekNumber;
        while (rowIndex === -1) {
            var isCorrectCell = checkCellGroupingInfo(viewCellsData[currentRowIndex][dayOfWeek], appointment);
            if (isCorrectCell) {
                rowIndex = currentRowIndex;
            }
            currentRowIndex += rowsInOneGroup;
        }
        return rowIndex;
    };

    var TOP_CELL_OFFSET = 0.32;
    var CELL_BOUND_OFFSET_PX = 1;
    var getCellRect$1 = function (date, appointment, viewCellsData, viewMetaData, cellElementsMeta, takePrev, multiline) {
        var cellIndex = multiline
            ? getMonthCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev) : getAllDayCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev);
        var _a = cellElementsMeta.getCellRects[cellIndex](), top = _a.top, left = _a.left, width = _a.width, height = _a.height;
        var parentRect = cellElementsMeta.parentRect();
        return {
            top: top,
            left: left,
            width: width,
            height: height,
            parentRect: parentRect,
        };
    };
    var getHorizontalRectByAppointmentData = function (appointment, viewMetaData, _a) {
        var multiline = _a.multiline, viewCellsData = _a.viewCellsData, cellElementsMeta = _a.cellElementsMeta;
        var firstCellRect = getCellRect$1(appointment.start.toDate(), appointment, viewCellsData, viewMetaData, cellElementsMeta, false, multiline);
        var lastCellRect = getCellRect$1(appointment.end.toDate(), appointment, viewCellsData, viewMetaData, cellElementsMeta, true, multiline);
        var top = firstCellRect.top + (firstCellRect.height * TOP_CELL_OFFSET);
        var height = firstCellRect.height - (firstCellRect.height * TOP_CELL_OFFSET);
        return {
            top: top - firstCellRect.parentRect.top,
            left: (firstCellRect.left - firstCellRect.parentRect.left) + CELL_BOUND_OFFSET_PX,
            width: ((lastCellRect.left - firstCellRect.left) + firstCellRect.width) - CELL_BOUND_OFFSET_PX,
            height: height,
            parentWidth: firstCellRect.parentRect.width,
        };
    };

    var DAY_COUNT = 7;
    var MONTH_LENGTH = 31;
    var monthCellsData = function (currentDate, firstDayOfWeek, intervalCount, today) {
        if (intervalCount === void 0) { intervalCount = 1; }
        var targetDate = moment(currentDate);
        var currentMonths = [targetDate.month()];
        while (currentMonths.length < intervalCount) {
            currentMonths.push(targetDate.add(1, 'months').month());
        }
        var firstMonthDate = moment(currentDate).date(1);
        var firstMonthDay = firstMonthDate.day() - firstDayOfWeek;
        var prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;
        var prevMonth = moment(currentDate).subtract(1, 'months');
        var prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);
        var from = moment()
            .year(prevMonth.year())
            .month(prevMonth.month())
            .date(prevMonthStartDay)
            .startOf('day');
        var result = [];
        while (result.length < (Math.trunc((MONTH_LENGTH * intervalCount) / DAY_COUNT) + 2)) {
            var week = [];
            while (week.length < DAY_COUNT) {
                week.push({
                    startDate: from.toDate(),
                    endDate: from.clone().add(1, 'day').toDate(),
                    otherMonth: currentMonths.findIndex(function (month) { return month === from.month(); }) === -1,
                    today: today ? moment(today).isSame(from, 'date') : false,
                });
                from.add(1, 'day');
            }
            result.push(week);
        }
        return result;
    };
    var calculateMonthDateIntervals = function (appointments, leftBound, rightBound) { return [
        appointments
            .map(function (_a) {
            var start = _a.start, end = _a.end, restArgs = __rest(_a, ["start", "end"]);
            return (__assign({ start: moment(start), end: moment(end) }, restArgs));
        })
            .reduce(function (acc, appointment) {
            return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, [], false));
        }, [])
            .reduce(function (acc, appointment) { return (__spread(acc, sliceAppointmentByWeek({ left: moment(leftBound), right: moment(rightBound) }, appointment, DAY_COUNT))); }, []),
    ]; };

    var calculateAllDayDateIntervals = function (appointments, leftBound, rightBound, excludedDays) { return [
        appointments
            .map(function (_a) {
            var start = _a.start, end = _a.end, restArgs = __rest(_a, ["start", "end"]);
            return (__assign({ start: moment(start), end: moment(end) }, restArgs));
        })
            .reduce(function (acc, appointment) {
            return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false));
        }, [])
            .filter(function (appointment) { return allDayPredicate(appointment); })
            .reduce(function (acc, appointment) { return (__spread(acc, sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays))); }, []),
    ]; };

    var getGroupFromResourceInstance = function (resourceInstance) { return ({
        id: resourceInstance.id,
        fieldName: resourceInstance.fieldName,
        text: resourceInstance.text,
    }); };
    var addGroupInfoToCells = function (currentGroup, groups, sortedResources, viewCellRow, index, endOfGroup, groupOrientation) { return viewCellRow.map(function (viewCell, cellIndex) {
        var groupedCell = addGroupInfoToCell(currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation);
        return cellIndex === viewCellRow.length - 1 && groupOrientation === HORIZONTAL_GROUP_ORIENTATION
            ? __assign(__assign({}, groupedCell), { endOfGroup: true }) : groupedCell;
    }); };
    var addGroupInfoToCell = function (currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation) {
        var previousIndex = index;
        var groupingInfo = groups.reduceRight(function (acc, group, currentIndex) {
            if (currentIndex === groups.length - 1)
                return acc;
            var previousResourceLength = sortedResources[currentIndex + 1].instances.length;
            var currentGroupingInstance = group[Math.floor(previousIndex / previousResourceLength)];
            previousIndex = currentIndex;
            return __spread(acc, [currentGroupingInstance]);
        }, [currentGroup]);
        return __assign(__assign({}, viewCell), { groupingInfo: groupingInfo, endOfGroup: endOfGroup, groupOrientation: groupOrientation });
    };
    var getCurrentGroup = function (groups, resources, index, group) {
        var currentIndex = index;
        return groups.reduceRight(function (groupAcc, groupsRow, rowIndex) {
            if (rowIndex === groups.length - 1) {
                return groupAcc;
            }
            currentIndex = Math.floor(currentIndex / resources[rowIndex + 1].instances.length);
            var currentInstance = groupsRow[currentIndex];
            return __spread(groupAcc, [
                currentInstance,
            ]);
        }, [group]);
    };
    var groupAppointments = function (appointments, resources, groups) {
        if (!resources || !groups)
            return [appointments.slice()];
        var mainResource = resources.find(function (resource) { return resource.isMain; });
        return groups[groups.length - 1].map(function (group, index) {
            var currentGroup = getCurrentGroup(groups, resources, index, group);
            return appointments.reduce(function (acc, appointment) {
                var _a;
                var belongsToGroup = currentGroup.reduce(function (isBelonging, groupItem) { return (isBelonging && groupItem.id === appointment[groupItem.fieldName]); }, true);
                if (!belongsToGroup)
                    return acc;
                var currentMainResourceId = currentGroup.find(function (groupItem) { return groupItem.fieldName === mainResource.fieldName; }).id;
                var updatedAppointment = __assign(__assign({}, appointment), { dataItem: __assign(__assign({}, appointment.dataItem), (_a = {}, _a[mainResource.fieldName] = rearrangeResourceIds(mainResource, appointment, currentMainResourceId), _a)), resources: appointment.resources && rearrangeResources(mainResource, appointment, currentMainResourceId) });
                return __spread(acc, [updatedAppointment]);
            }, []);
        });
    };
    var rearrangeResourceIds = function (mainResource, appointment, mainResourceId) {
        if (!mainResource.allowMultiple) {
            return mainResourceId;
        }
        return __spread([
            mainResourceId
        ], appointment.dataItem[mainResource.fieldName].filter(function (id) { return id !== mainResourceId; }));
    };
    var rearrangeResources = function (mainResource, appointment, currentResourceInstanceId) {
        var _a;
        if (!mainResource.allowMultiple) {
            return appointment.resources;
        }
        var resources = appointment.resources.slice();
        var firstMainResource = resources.findIndex(function (el) { return el.isMain; });
        var currentResourceIndex = resources.findIndex(function (el) { return el.isMain && el.id === currentResourceInstanceId; });
        _a = __read([resources[currentResourceIndex], resources[firstMainResource]], 2), resources[firstMainResource] = _a[0], resources[currentResourceIndex] = _a[1];
        return resources;
    };
    var expandGroupedAppointment = function (appointment, grouping, resources) {
        if (!resources || !grouping) {
            return [appointment];
        }
        return resources
            .reduce(function (acc, resource) {
            var isGroupedByResource = grouping.find(function (group) { return group.resourceName === resource.fieldName; }) !== undefined;
            if (!isGroupedByResource)
                return acc;
            var resourceField = resource.fieldName;
            if (!resource.allowMultiple) {
                return acc.reduce(function (accumulatedAppointments, currentAppointment) {
                    var _a;
                    return __spread(accumulatedAppointments, [
                        __assign(__assign({}, currentAppointment), (_a = {}, _a[resourceField] = currentAppointment.dataItem[resourceField], _a)),
                    ]);
                }, []);
            }
            return acc.reduce(function (accumulatedAppointments, currentAppointment) { return __spread(accumulatedAppointments, currentAppointment.dataItem[resourceField].map(function (resourceValue) {
                var _a;
                return (__assign(__assign({}, currentAppointment), (_a = {}, _a[resourceField] = resourceValue, _a.key = generateMultipleResourceKey(currentAppointment.key, resourceValue), _a)));
            })); }, []);
        }, [appointment]);
    };
    var generateMultipleResourceKey = function (previousKey, resourceValue) { return previousKey + "_" + resourceValue; };
    var getGroupingInfoFromGroups = function (groups, groupIndex) {
        var previousIndex = groupIndex;
        return groups.reduceRight(function (acc, currentGroups, currentIndex) {
            if (currentIndex === groups.length - 1)
                return acc;
            var previousResourceLength = groups[currentIndex + 1].length / currentGroups.length;
            var currentGroupingInstance = currentGroups[Math.floor(previousIndex / previousResourceLength)];
            previousIndex = currentIndex;
            return __spread(acc, [currentGroupingInstance]);
        }, [getGroupsLastRow(groups)[groupIndex]]);
    };
    var getGroupsLastRow = function (groups) { return groups[groups.length - 1]; };

    var filterResourcesByGrouping = function (resources, grouping) { return resources.filter(function (resource) { return grouping.find(function (resourceId) { return resource.fieldName === resourceId.resourceName; }); }); };
    var sortFilteredResources = function (resources, grouping) { return grouping.map(function (_a) {
        var resourceName = _a.resourceName;
        return resources.find(function (resource) { return resource.fieldName === resourceName; });
    }); };
    var getGroupsFromResources = function (sortedAndFilteredResources) { return sortedAndFilteredResources.reduce(function (acc, resource, index) {
        if (index === 0) {
            return [resource.instances.map(function (instance) { return getGroupFromResourceInstance(instance); })];
        }
        return __spread(acc, [
            acc[index - 1].reduce(function (currentResourceNames) { return __spread(currentResourceNames, resource.instances.map(function (instance) { return getGroupFromResourceInstance(instance); })); }, []),
        ]);
    }, []); };
    var expandViewCellsDataWithGroups = function (viewCellsData, groups, sortedResources, groupByDate, groupOrientation) {
        if (groups.length === 0)
            return viewCellsData;
        if (groupByDate) {
            return expandCellsWithGroupedByDateData(viewCellsData, groups, sortedResources);
        }
        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
            return expandHorizontallyGroupedCells(viewCellsData, groups, sortedResources);
        }
        return expandVerticallyGroupedCells(viewCellsData, groups, sortedResources);
    };
    var expandCellsWithGroupedByDateData = function (viewCellsData, groups, sortedResources) { return viewCellsData.map(function (cellsRow) { return cellsRow.reduce(function (acc, viewCell) {
        var groupedCells = getGroupsLastRow(groups).map(function (group, index) { return addGroupInfoToCell(group, groups, sortedResources, viewCell, index, false, HORIZONTAL_GROUP_ORIENTATION); });
        groupedCells[groupedCells.length - 1] = __assign(__assign({}, groupedCells[groupedCells.length - 1]), { endOfGroup: true });
        return __spread(acc, groupedCells);
    }, []); }); };
    var expandHorizontallyGroupedCells = function (viewCellsData, groups, sortedResources) { return getGroupsLastRow(groups).reduce(function (acc, group, index) {
        if (index === 0) {
            return viewCellsData.map(function (viewCellsRow) {
                return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, false, HORIZONTAL_GROUP_ORIENTATION);
            });
        }
        return acc.map(function (item, id) { return __spread(item, addGroupInfoToCells(group, groups, sortedResources, viewCellsData[id], index, false, HORIZONTAL_GROUP_ORIENTATION)); });
    }, [[]]); };
    var expandVerticallyGroupedCells = function (viewCellsData, groups, sortedResources) { return getGroupsLastRow(groups).reduce(function (acc, group, index) {
        if (index === 0) {
            return viewCellsData.map(function (viewCellsRow, viewRowIndex) { return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION); });
        }
        return __spread(acc, viewCellsData.map(function (viewCellsRow, viewRowIndex) {
            return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION);
        }));
    }, [[]]); };
    var updateGroupingWithMainResource = function (grouping, resources) { return grouping
        || [{ resourceName: resources.find(function (resource) { return resource.isMain; }).fieldName }]; };
    var expandGroups = function (appointments, grouping, resources, groups, excludedDays, sliceByDay) {
        if (sliceByDay === void 0) { sliceByDay = false; }
        var slicedAppointments = sliceByDay ?
            appointments[0].reduce(function (acc, appointment) { return (__spread(acc, sliceAppointmentsByDays(appointment, excludedDays))); }, []) : appointments[0];
        var expandedAppointments = slicedAppointments
            .reduce(function (acc, appointment) { return __spread(acc, expandGroupedAppointment(appointment, grouping, resources)); }, []);
        return groupAppointments(expandedAppointments, resources, groups);
    };
    var updateTimeTableCellElementsMeta = function (timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData, currentView) {
        if (checkCellElementsMeta(timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists)) {
            return timeTableElementsMeta;
        }
        var _a = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups), groupCount = _a.groupCount, timeTableWidth = _a.timeTableWidth, groupSize = _a.groupSize, validGetCellRects = _a.validGetCellRects;
        var allDayPanelsLeft = groupCount;
        while (allDayPanelsLeft > 0) {
            allDayPanelsLeft -= 1;
            validGetCellRects.splice(allDayPanelsLeft * (timeTableWidth + groupSize), timeTableWidth);
        }
        return {
            parentRect: timeTableElementsMeta.parentRect,
            getCellRects: validGetCellRects,
        };
    };
    var updateAllDayCellElementsMeta = function (allDayElementsMeta, timeTableElementsMeta, groupOrientation, groups, allDayPanelExists, viewCellsData, currentView) {
        if (checkCellElementsMeta(timeTableElementsMeta, groupOrientation, currentView, allDayPanelExists)) {
            return allDayElementsMeta;
        }
        var _a = initializeCellElementsData(timeTableElementsMeta, viewCellsData, groups), groupCount = _a.groupCount, timeTableWidth = _a.timeTableWidth, groupSize = _a.groupSize, validGetCellRects = _a.validGetCellRects;
        var allDayPanelsLeft = groupCount;
        while (allDayPanelsLeft > 0) {
            allDayPanelsLeft -= 1;
            validGetCellRects.splice(groupSize * allDayPanelsLeft + timeTableWidth * (allDayPanelsLeft + 1), groupSize);
        }
        return {
            parentRect: timeTableElementsMeta.parentRect,
            getCellRects: validGetCellRects,
        };
    };
    var checkCellElementsMeta = function (cellElementsMeta, groupOrientation, currentView, allDayPanelExists) { return groupOrientation(currentView.name) === HORIZONTAL_GROUP_ORIENTATION
        || !allDayPanelExists || !cellElementsMeta.getCellRects; };
    var initializeCellElementsData = function (cellElementsMeta, viewCellsData, groups) {
        var timeTableWidth = viewCellsData[0].length;
        var groupCount = getGroupsLastRow(groups).length;
        var groupHeight = viewCellsData.length / groupCount;
        return {
            groupCount: groupCount,
            timeTableWidth: timeTableWidth,
            groupSize: timeTableWidth * groupHeight,
            validGetCellRects: cellElementsMeta.getCellRects.slice(),
        };
    };
    var updateTimeCellsData = function (viewCellsData, timeCellsData, groups, sortedResources, groupOrientation) {
        var firstViewDate = viewCellsData[0][0].startDate;
        if (!containsDSTChange(firstViewDate)) {
            return viewCellsData;
        }
        if (groupOrientation !== VERTICAL_GROUP_ORIENTATION) {
            return timeCellsData;
        }
        return expandVerticallyGroupedCells(timeCellsData, groups, sortedResources);
    };

    var allDayRects = function (appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {
        var intervals = calculateAllDayDateIntervals(appointments, startViewDate, endViewDate, excludedDays);
        var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, sliceAppointments);
        return calculateRectByDateAndGroupIntervals({
            growDirection: HORIZONTAL_TYPE,
            multiline: false,
        }, groupedIntervals, getHorizontalRectByAppointmentData, {
            startViewDate: startViewDate,
            endViewDate: endViewDate,
            viewCellsData: viewCellsData,
            cellElementsMeta: cellElementsMeta,
            excludedDays: excludedDays,
        }, {
            groupOrientation: groupOrientation,
            groupedByDate: sliceAppointments,
            groupCount: groups ? getGroupsLastRow(groups).length : 1,
        });
    };
    var verticalTimeTableRects = function (appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDuration, cellElementsMeta, grouping, resources, groups, groupOrientation, groupByDate) {
        var intervals = calculateWeekDateIntervals(appointments, startViewDate, endViewDate, excludedDays, cellDuration);
        var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, false);
        return calculateRectByDateAndGroupIntervals({
            growDirection: VERTICAL_TYPE,
            multiline: false,
        }, groupedIntervals, getVerticalRectByAppointmentData, {
            startViewDate: startViewDate,
            endViewDate: endViewDate,
            viewCellsData: viewCellsData,
            cellDuration: cellDuration,
            cellElementsMeta: cellElementsMeta,
        }, {
            groupOrientation: groupOrientation,
            groupedByDate: groupByDate,
            groupCount: groups ? getGroupsLastRow(groups).length : 1,
        });
    };
    var horizontalTimeTableRects = function (appointments, startViewDate, endViewDate, viewCellsData, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {
        var intervals = calculateMonthDateIntervals(appointments, startViewDate, endViewDate);
        var groupedIntervals = expandGroups(intervals, grouping, resources, groups, [], sliceAppointments);
        return calculateRectByDateAndGroupIntervals({
            growDirection: HORIZONTAL_TYPE,
            multiline: true,
        }, groupedIntervals, getHorizontalRectByAppointmentData, {
            startViewDate: startViewDate,
            endViewDate: endViewDate,
            viewCellsData: viewCellsData,
            cellElementsMeta: cellElementsMeta,
        }, {
            groupOrientation: groupOrientation,
            groupedByDate: sliceAppointments,
            groupCount: groups ? getGroupsLastRow(groups).length : 1,
        });
    };

    var dateTimeFormatInstance = function (locale, formatOptions) { return new Intl.DateTimeFormat(locale, formatOptions); };

    var appointments = function (data) { return data.map(function (appointment, index) { return (__assign(__assign(__assign(__assign(__assign({ dataItem: appointment, start: appointment.startDate }, appointment.endDate !== undefined ? {
        end: appointment.endDate,
    } : {
        end: appointment.startDate,
        dataItem: __assign(__assign({}, appointment), { endDate: appointment.startDate }),
    }), appointment.allDay !== undefined && {
        allDay: appointment.allDay,
    }), appointment.rRule !== undefined && {
        rRule: appointment.rRule,
    }), appointment.exDate !== undefined && {
        exDate: appointment.exDate,
    }), { key: appointment.id || index })); }); };
    var formatDateTimeGetter = function (locale) {
        var cache = new Map(); // any -> type
        var formatter = function (nextDate, nextOptions) {
            if (nextDate === undefined)
                return '';
            var date = convertToMoment(nextDate).toDate();
            var formatInstance = cache.get(nextOptions);
            if (!formatInstance) {
                formatInstance = dateTimeFormatInstance(locale, nextOptions);
                cache.set(nextOptions, formatInstance);
            }
            return formatInstance.format(date);
        };
        return formatter;
    };

    var getCellKey = function (groups, groupIndex, rowNumber) {
        var currentIndex = groupIndex;
        return groups.reduceRight(function (acc, groupRow, rowIndex) {
            if (rowNumber < rowIndex)
                return acc;
            var currentKey = groupRow[currentIndex].id;
            if (rowIndex > 0) {
                var currentRowLength = groups[rowIndex].length / groups[rowIndex - 1].length;
                currentIndex = Math.floor(currentIndex / currentRowLength);
            }
            return acc + currentKey;
        }, '');
    };
    var getRowFromGroups = function (width, groupRow, cellStyle, groups, rowIndex) {
        var row = [];
        var currentRowLength = groupRow.length;
        var standardWidth = width / getGroupsLastRow(groups).length;
        var colSpan = getGroupsLastRow(groups).length / currentRowLength;
        var _loop_1 = function (i) {
            row = __spread(row, groupRow.reduce(function (acc, group, index) { return __spread(acc, [
                {
                    group: group,
                    colSpan: colSpan,
                    key: getCellKey(groups, index, rowIndex) + i,
                    left: cellStyle.left,
                    endOfGroup: index === currentRowLength - 1,
                },
            ]); }, []));
        };
        for (var i = 0; i < standardWidth; i += 1) {
            _loop_1(i);
        }
        return row;
    };
    var getVerticalRowFromGroups = function (groups, groupIndex, groupingPanelRowSpan, timeTableCellHeight, addAllDayHeight, allDayCellHeight) { return groups.reduce(function (acc, groupColumn, columnIndex) {
        var groupSpan = getGroupsLastRow(groups).length / groupColumn.length;
        var cellIndex = groupIndex / groupSpan;
        var baseHeight = (groupingPanelRowSpan * groupSpan * timeTableCellHeight)
            / getGroupsLastRow(groups).length;
        var allDayHeight = groupSpan * allDayCellHeight;
        return groupIndex % groupSpan !== 0 ? acc : __spread(acc, [
            {
                group: groupColumn[cellIndex],
                rowSpan: groupSpan,
                height: addAllDayHeight ? baseHeight + allDayHeight : baseHeight,
                key: getCellKey(groups, cellIndex, columnIndex),
            },
        ]);
    }, []); };

    var getLabelsForSingleGroup = function (groups, cellsData, groupIndex, groupHeight) {
        var currentGroupIndex = groupIndex * groupHeight;
        var nextGroupIndex = currentGroupIndex + groupHeight;
        return cellsData.slice(currentGroupIndex, nextGroupIndex - 1).reduce(function (acc, days) { return ((__spread(acc, [
            {
                startDate: days[0].startDate,
                endDate: days[0].endDate,
                key: days[0].endDate + getCellKey(groups, groupIndex, groups.length - 1),
                groupingInfo: days[0].groupingInfo,
            },
        ]))); }, []);
    };
    var getLabelsForAllGroups = function (cellsData, groups, groupOrientation) {
        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
            return [cellsData.map(function (cellsRow) { return ({
                    startDate: cellsRow[0].startDate,
                    endDate: cellsRow[0].endDate,
                    groupingInfo: cellsRow[0].groupingInfo,
                    key: cellsRow[0].endDate,
                }); })];
        }
        var groupCount = getGroupsLastRow(groups).length;
        var singleGroupHeight = cellsData.length / groupCount;
        return getGroupsLastRow(groups).reduce(function (acc, group, groupIndex) { return __spread(acc, [
            getLabelsForSingleGroup(groups, cellsData, groupIndex, singleGroupHeight),
        ]); }, []);
    };
    var prepareVerticalViewCellsData = function (cellsData, allDayCellsData) {
        var groupCount = (allDayCellsData === null || allDayCellsData === void 0 ? void 0 : allDayCellsData.length) || 1;
        var validCellsData = [];
        var groupHeight = cellsData.length / groupCount;
        for (var i = 0; i < groupCount; i += 1) {
            validCellsData.push(cellsData.slice(i * groupHeight, (i + 1) * groupHeight));
        }
        return validCellsData;
    };

    var changeCurrentDate = function (currentDate, _a) {
        var nextDate = _a.nextDate, step = _a.step, amount = _a.amount, direction = _a.direction;
        return (nextDate
            || moment(currentDate)[direction === 'back' ? 'subtract' : 'add'](amount, step)
                .toDate()
            || moment().subtract(amount, step));
    };
    var setCurrentViewName = function (currentViewName, nextViewName) { return nextViewName; };

    var setAppointmentMeta = function (prevAppointmentMeta, _a) {
        var target = _a.target, data = _a.data;
        return ({ target: target, data: data });
    };

    var OPEN_COMMAND_BUTTON = 'open';
    var CLOSE_COMMAND_BUTTON = 'close';
    var DELETE_COMMAND_BUTTON = 'delete';
    var CANCEL_COMMAND_BUTTON = 'cancel';
    var COMMIT_COMMAND_BUTTON = 'commit';

    var setAppointmentData = function (prevAppointmentData, _a) {
        var appointmentData = _a.appointmentData;
        return appointmentData;
    };

    var getWeekNumberLabels = function (getMessage) {
        return WEEK_NUMBER_LABELS.map(function (weekNumberLabel, index) { return ({
            text: getMessage(weekNumberLabel),
            id: index,
        }); });
    };
    var getDaysOfWeek = function (formatDate, firstDayOfWeek) {
        var daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);
        var daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);
        return daysOfWeekDates.map(function (day, index) { return ({
            text: getDayOfWeek(day, formatDate),
            id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0],
        }); });
    };
    var getMonths = function (formatDate) { return MONTHS_DATES.map(function (month, index) { return ({
        text: getMonth(month, formatDate),
        id: getMonthId(index),
    }); }); };
    var getMonthsWithOf = function (getMessage, formatDate) { return MONTHS_DATES.map(function (month, index) { return ({
        text: getMonthWithOf(month, getMessage, formatDate),
        id: getMonthId(index),
    }); }); };
    var getMonthWithOf = function (date, getMessage, formatDate) { return getMessage('ofLabel')
        + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\d.,]/g, '').toString(); };
    var getMonth = function (date, formatDate) { return formatDate(date, LONG_MONTH_OPTIONS); };
    var getDayOfWeek = function (date, formatDate) { return formatDate(date, LONG_WEEK_DAY_OPTIONS); };
    var getMonthId = function (index) { return index + 1; };
    var getAvailableRecurrenceOptions = function (getMessage) {
        return REPEAT_TYPES_ARRAY.map(function (type) { return ({
            text: getMessage(type),
            id: type,
        }); });
    };
    var getCountDependingOnRecurrenceType = function (frequency) {
        var count;
        switch (frequency) {
            case RRULE_REPEAT_TYPES.YEARLY:
                count = BASIC_YEALY_COUNT;
                break;
            case RRULE_REPEAT_TYPES.MONTHLY:
                count = BASIC_MONTHLY_COUNT;
                break;
            case RRULE_REPEAT_TYPES.WEEKLY:
                count = BASIC_WEEKLY_COUNT;
                break;
            case RRULE_REPEAT_TYPES.DAILY:
                count = BASIC_DAILY_COUNT;
                break;
        }
        return count;
    };
    var checkIsNaturalNumber = function (number) { return number > 0 && number <= Number.MAX_SAFE_INTEGER; };

    var callActionIfExists = function (action, payload) {
        if (action) {
            action(payload);
        }
    };
    var isAllDayCell = function (startDate, endDate) { return moment(endDate).diff(moment(startDate), 'days') >= 1; };
    var changeRecurrenceFrequency = function (rule, freq, startDate) {
        if (!rule) {
            if (freq === RRULE_REPEAT_TYPES.MONTHLY) {
                return (new rrule.RRule(__assign(__assign({}, DEFAULT_RULE_OBJECT), { freq: freq, bymonthday: [startDate.getDate()], count: getCountDependingOnRecurrenceType(freq) }))).toString();
            }
            if (freq === RRULE_REPEAT_TYPES.YEARLY) {
                return (new rrule.RRule(__assign(__assign({}, DEFAULT_RULE_OBJECT), { freq: freq, bymonthday: [startDate.getDate()], bymonth: startDate.getMonth() + 1, count: getCountDependingOnRecurrenceType(freq) }))).toString();
            }
            return (new rrule.RRule(__assign(__assign({}, DEFAULT_RULE_OBJECT), { freq: freq, count: getCountDependingOnRecurrenceType(freq) }))).toString();
        }
        var options = rrule.RRule.parseString(rule);
        if (options.freq === freq)
            return rule;
        options.freq = freq;
        options.count = getCountDependingOnRecurrenceType(freq);
        if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {
            options.bymonthday = startDate.getDate();
        }
        if (freq === RRULE_REPEAT_TYPES.YEARLY) {
            options.bymonth = startDate.getMonth() + 1;
        }
        if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {
            options.bymonthday = undefined;
        }
        options.byweekday = undefined;
        var nextRule = new rrule.RRule(options);
        return nextRule.toString();
    };
    var getRecurrenceOptions = function (rule) { return !rule ? null : rrule.RRule.parseString(rule); };
    var changeRecurrenceOptions = function (options) {
        return options ? (new rrule.RRule(__assign({}, options))).toString() : undefined;
    };
    var handleStartDateChange = function (nextStartDay, options) {
        if (nextStartDay <= 31) {
            var nextOptions = __assign(__assign({}, options), { bymonthday: nextStartDay });
            return changeRecurrenceOptions(nextOptions);
        }
        return changeRecurrenceOptions(options);
    };
    var handleToDayOfWeekChange = function (weekNumber, dayOfWeek, options) {
        var validDayOfWeek = dayOfWeek > 0 ? dayOfWeek - 1 : 6;
        var validWeekNumber = weekNumber === 4 ? -1 : weekNumber + 1;
        var rruleDayOfWeek = RRULE_DAYS_OF_WEEK[validDayOfWeek];
        var nextOptions = __assign(__assign({}, options), { byweekday: [rruleDayOfWeek.nth(validWeekNumber)], bymonthday: undefined });
        return changeRecurrenceOptions(nextOptions);
    };
    var getRRuleFrequency = function (repeatType) { return RRULE_REPEAT_TYPES[repeatType.toUpperCase()]; };
    var getFrequencyString = function (rRuleFrequency) {
        if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY)
            return REPEAT_TYPES.DAILY;
        if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY)
            return REPEAT_TYPES.WEEKLY;
        if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY)
            return REPEAT_TYPES.MONTHLY;
        if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY)
            return REPEAT_TYPES.YEARLY;
        return REPEAT_TYPES.NEVER;
    };
    var getRadioGroupDisplayData = function (recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption) {
        if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {
            return {
                dayNumberTextField: recurrenceOptions.bymonthday,
                weekNumber: stateWeekNumber,
                dayOfWeek: stateDayOfWeek,
                radioGroupValue: firstOption,
            };
        }
        if (!recurrenceOptions.byweekday) {
            return {
                dayOfWeek: stateDayOfWeek,
                weekNumber: stateWeekNumber,
                radioGroupValue: secondOption,
                dayNumberTextField: stateDayNumber,
            };
        }
        var dayOfWeek = recurrenceOptions.byweekday[0].weekday < 6
            ? recurrenceOptions.byweekday[0].weekday + 1 : 0;
        var weekNumber = recurrenceOptions.byweekday[0].n === -1
            ? LAST_WEEK
            : recurrenceOptions.byweekday[0].n - 1;
        return {
            dayOfWeek: dayOfWeek,
            weekNumber: weekNumber,
            radioGroupValue: secondOption,
            dayNumberTextField: stateDayNumber,
        };
    };
    var handleChangeFrequency = function (repeatType, rRule, startDate, action) {
        var rruleRepeatType = getRRuleFrequency(repeatType);
        var nextRRule;
        if (rruleRepeatType !== undefined) {
            nextRRule = changeRecurrenceFrequency(rRule, rruleRepeatType, startDate);
        }
        action({ rRule: nextRRule });
    };
    var handleWeekDaysChange = function (options, currentWeekDay) {
        var byWeekDay = options.byweekday || [];
        var index = byWeekDay.findIndex(function (_a) {
            var weekday = _a.weekday;
            return weekday === currentWeekDay;
        });
        var isAdded = index === -1;
        if (isAdded) {
            byWeekDay.push(RRULE_DAYS_OF_WEEK[currentWeekDay]);
        }
        else if (index > -1) {
            byWeekDay.splice(index, 1);
        }
        if (byWeekDay === 0)
            return __assign(__assign({}, options), { byweekday: undefined });
        return __assign(__assign({}, options), { byweekday: byWeekDay });
    };
    var getDaysOfWeekArray = function (firstDayOfWeek) {
        var firstPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) { return dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1; });
        var secondPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) { return dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1; });
        return firstDayOfWeek !== 0 ? __spread(firstPart, secondPart) : __spread(secondPart, firstPart);
    };
    var getDaysOfWeekDates = function (firstDayOfWeek) {
        var firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);
        var secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);
        return __spread(firstPart, secondPart);
    };
    var checkMultipleResourceFields = function (resourceFields, resources) { return resources.reduce(function (acc, resource) {
        var _a;
        if (!resource.allowMultiple) {
            return acc;
        }
        var fieldName = resource.fieldName;
        var field = resourceFields[fieldName];
        return __assign(__assign({}, acc), (_a = {}, _a[fieldName] = Array.isArray(field) ? field : [field], _a));
    }, resourceFields); };

    var addAppointment = function (addedAppointmentData, _a) {
        var _b = _a === void 0 ? { appointmentData: {} } : _a, appointmentData = _b.appointmentData;
        return appointmentData;
    };
    var cancelAddedAppointment = function () { return ({}); };
    var startEditAppointment = function (prevEditingAppointment, appointmentData) { return appointmentData; };
    var stopEditAppointment = function () { return null; };
    var changeAppointment = function (appointment, _a) {
        var change = _a.change;
        return (__assign(__assign({}, appointment), change));
    };
    var cancelChanges = function () { return ({}); };

    var changedAppointmentById = function (changes, appointmentId) {
        var _a;
        return (_a = {}, _a[appointmentId] = changes, _a);
    };

    var mergeNewChanges = function (appointmentData, changes) {
        var appointment = __assign({}, appointmentData);
        delete appointment.id;
        delete appointment.rRule;
        delete appointment.exDate;
        delete appointment.parentData;
        return __assign(__assign({}, appointment), changes);
    };
    var reduceExDate = function (prevExDate, boundDate) {
        if (prevExDate.length > 0) {
            return prevExDate.split(',').reduce(function (acc, date) {
                var momentDate = moment.utc(date);
                if (momentDate.isBefore(boundDate)) {
                    return __spread(acc, [date]);
                }
                return acc;
            }, []).join(',');
        }
        return undefined;
    };
    var configureExDate = function (exDate, date) {
        var currentExDate = moment.utc(date).format('YYYYMMDDTHHmmss') + "Z";
        return exDate
            ? exDate + "," + currentExDate
            : currentExDate;
    };
    var configureDateSequence = function (rRule, exDate, prevStartDate, nextStartDate) {
        var rruleSet = getRRuleSetWithExDates(exDate);
        var currentOptions = rrule.RRule.parseString(rRule);
        var correctedOptions = currentOptions.until
            ? __assign(__assign({}, currentOptions), { until: moment(getUTCDate(currentOptions.until)).toDate() }) : currentOptions;
        var prevStartDateUTC = moment(getUTCDate(prevStartDate)).toDate();
        rruleSet.rrule(new rrule.RRule(__assign(__assign({}, correctedOptions), { dtstart: prevStartDateUTC })));
        if (currentOptions.count || currentOptions.until) {
            return rruleSet.all()
                // we shouldn't use `new Date(string)` because this function has different results in Safari
                .map(function (nextDate) { return moment(formatDateToString(nextDate)).toDate(); });
        }
        var leftBound = prevStartDateUTC;
        var rightBound = moment(getUTCDate(nextStartDate)).toDate();
        return rruleSet.between(leftBound, rightBound, true)
            .map(function (nextDate) { return moment(formatDateToString(nextDate)).toDate(); });
    };
    var configureICalendarRules = function (rRule, options) {
        var rruleSet = new rrule.RRuleSet();
        rruleSet.rrule(new rrule.RRule(__assign(__assign({}, rrule.RRule.parseString(rRule)), options)));
        return rruleSet.valueOf();
    };
    var changeCurrentAndFollowing = function (appointmentData, changes, changeAllAction) {
        var _a;
        var rRule = appointmentData.rRule, startDate = appointmentData.startDate, parentData = appointmentData.parentData, _b = appointmentData.exDate, prevExDate = _b === void 0 ? '' : _b, id = appointmentData.id;
        var _c = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule), initialSequence = _c.initialSequence, currentChildIndex = _c.currentChildIndex;
        if (currentChildIndex === 0)
            return changeAllAction(appointmentData, changes);
        var changedRules = configureICalendarRules(rRule, {
            dtstart: moment.utc(parentData.startDate).toDate(),
            until: moment.utc(initialSequence[currentChildIndex - 1]).toDate(),
            count: null,
        });
        var nextExDate = reduceExDate(prevExDate, startDate);
        return {
            changed: (_a = {},
                _a[id] = __assign({ rRule: changedRules[1].slice(6) }, nextExDate && prevExDate !== nextExDate ? { exDate: nextExDate } : {}),
                _a),
        };
    };
    var getAppointmentSequenceData = function (prevStartDate, startDate, exDate, rRule) {
        var initialSequence = configureDateSequence(rRule, exDate, moment.utc(prevStartDate).toDate(), moment.utc(startDate).toDate());
        var currentChildIndex = initialSequence
            .findIndex(function (date) { return moment(date).isSame(startDate); });
        return { initialSequence: initialSequence, currentChildIndex: currentChildIndex };
    };
    var deleteCurrent = function (appointmentData) {
        var _a;
        var currentSequence = configureDateSequence(appointmentData.rRule, appointmentData.exDate, moment.utc(appointmentData.parentData.startDate).toDate(), moment.utc(appointmentData.startDate).toDate());
        if (currentSequence.length === 1) {
            return deleteAll(appointmentData);
        }
        var nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate);
        return { changed: (_a = {}, _a[appointmentData.id] = { exDate: nextExDate }, _a) };
    };
    var deleteAll = function (appointmentData) {
        return { deleted: appointmentData.id };
    };
    var deleteCurrentAndFollowing = function (appointmentData) { return changeCurrentAndFollowing(appointmentData, {}, deleteAll); };
    var editAll = function (appointmentData, changes) {
        var _a, _b;
        var rRule = appointmentData.rRule, id = appointmentData.id;
        var initialRule = new rrule.RRule(rrule.RRule.parseString(rRule));
        if (changes.startDate
            && moment.utc(changes.startDate).isAfter(initialRule.options.until)) {
            return {
                changed: (_a = {},
                    _a[id] = __assign(__assign({}, changes), { rRule: 'FREQ=DAILY;COUNT=1', exDate: '' }),
                    _a),
            };
        }
        return { changed: (_b = {}, _b[appointmentData.id] = changes, _b) };
    };
    var editCurrent = function (appointmentData, changes) {
        var _a;
        return ({
            changed: (_a = {},
                _a[appointmentData.id] = {
                    exDate: configureExDate(appointmentData.exDate, appointmentData.startDate),
                },
                _a),
            added: mergeNewChanges(appointmentData, changes),
        });
    };
    var editCurrentAndFollowing = function (appointmentData, changes) {
        var rRule = appointmentData.rRule, startDate = appointmentData.startDate, _a = appointmentData.exDate, prevExDate = _a === void 0 ? '' : _a, parentData = appointmentData.parentData;
        var initialRule = new rrule.RRule(rrule.RRule.parseString(rRule));
        var _b = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule), initialSequence = _b.initialSequence, currentChildIndex = _b.currentChildIndex;
        if (currentChildIndex === 0)
            return editAll(appointmentData, changes);
        var addedOptions = initialRule.options.count || initialRule.options.until
            ? { count: initialSequence.length - currentChildIndex }
            : {};
        var addedRules = configureICalendarRules(appointmentData.rRule, __assign({ dtstart: moment.utc(startDate).toDate() }, addedOptions));
        var addedAppointment = moment.utc(changes.startDate).isAfter(initialRule.options.until)
            ? { rRule: 'FREQ=DAILY;COUNT=1', exDate: '' } : { rRule: addedRules[1].slice(6) };
        return {
            changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,
            added: __assign(__assign({}, addedAppointment), mergeNewChanges(appointmentData, changes)),
        };
    };
    var preCommitChanges = function (changes, appointmentData, editType) {
        if (changes === null) {
            switch (editType) {
                case RECURRENCE_EDIT_SCOPE.ALL: {
                    return deleteAll(appointmentData);
                }
                case RECURRENCE_EDIT_SCOPE.CURRENT: {
                    return deleteCurrent(appointmentData);
                }
                case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {
                    return deleteCurrentAndFollowing(appointmentData);
                }
            }
        }
        else {
            switch (editType) {
                case RECURRENCE_EDIT_SCOPE.ALL: {
                    return editAll(appointmentData, changes);
                }
                case RECURRENCE_EDIT_SCOPE.CURRENT: {
                    return editCurrent(appointmentData, changes);
                }
                case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING: {
                    return editCurrentAndFollowing(appointmentData, changes);
                }
            }
        }
        return {};
    };

    var clamp = function (value, min, max) { return Math.max(Math.min(value, max), min); };
    var calculateInsideOffset = function (targetType, insidePart, cellDurationMinutes) { return targetType === VERTICAL_TYPE
        ? insidePart * cellDurationMinutes * 60 / 2 : 0; };
    var cellType = function (data) { return moment(data.startDate)
        .isSame(data.endDate, 'day') ? VERTICAL_TYPE : HORIZONTAL_TYPE; };
    var intervalDuration = function (data, type) { return moment(data.endDate).diff(data.startDate, type); };
    var cellIndex = function (getCellRects, clientOffset) { return getCellRects.findIndex(function (getCellRect) {
        var _a = getCellRect(), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;
        var isOver = clientOffset
            && clamp(clientOffset.x, left, right) === clientOffset.x
            && clamp(clientOffset.y, top, bottom) === clientOffset.y;
        return isOver;
    }); };
    var cellData = function (timeTableIndex, allDayIndex, viewCellsData, allDayCellsData) {
        var cellsData = allDayIndex !== -1 ? allDayCellsData : viewCellsData;
        var currentIndex = allDayIndex !== -1 ? allDayIndex : timeTableIndex;
        var tableWidth = cellsData[0].length;
        var rowIndex = Math.floor(currentIndex / tableWidth);
        var columnIndex = currentIndex % tableWidth;
        return cellsData[rowIndex][columnIndex];
    };
    var autoScroll = function (clientOffset, scrollingStrategy, scrollSpeed) {
        scroll(clientOffset.y, scrollingStrategy.topBoundary, scrollingStrategy.bottomBoundary, scrollingStrategy.changeVerticalScroll, scrollSpeed);
        scroll(clientOffset.x, scrollingStrategy.leftBoundary, scrollingStrategy.rightBoundary, scrollingStrategy.changeHorizontalScroll, scrollSpeed);
    };
    var scroll = function (offset, firstBoundary, secondBoundary, changeScroll, scrollSpeed) {
        if ((offset < firstBoundary + SCROLL_OFFSET) && (offset > firstBoundary)) {
            changeScroll(-scrollSpeed);
        }
        if (secondBoundary - SCROLL_OFFSET < offset) {
            changeScroll(+scrollSpeed);
        }
    };
    var timeBoundariesByResize = function (payload, targetData, targetType, cellDurationMinutes, insidePart) {
        if (targetType !== payload.appointmentType) {
            return { appointmentStartTime: undefined, appointmentEndTime: undefined };
        }
        var appointmentStartTime;
        var appointmentEndTime;
        var sourceType = payload.type;
        if (sourceType === RESIZE_TOP) {
            var insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);
            appointmentStartTime = moment(targetData.startDate)
                .add(insideTopOffset, SECONDS).toDate();
            appointmentEndTime = moment(payload.endDate).toDate();
        }
        if (sourceType === RESIZE_BOTTOM) {
            var insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE
                ? cellDurationMinutes * 60 / 2 : 0;
            appointmentEndTime = moment(targetData.endDate)
                .add(-insideBottomOffset, SECONDS).toDate();
            appointmentStartTime = moment(payload.startDate).toDate();
        }
        // keep origin appointment duration if coordinates are wrong
        if (moment(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {
            appointmentStartTime = moment(payload.startDate).toDate();
            appointmentEndTime = moment(payload.endDate).toDate();
        }
        return { appointmentStartTime: appointmentStartTime, appointmentEndTime: appointmentEndTime };
    };
    var timeBoundariesByDrag = function (payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {
        if (targetType === HORIZONTAL_TYPE
            && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {
            return {
                appointmentStartTime: targetData.startDate,
                appointmentEndTime: targetData.endDate,
                offsetTimeTop: 0,
            };
        }
        var offsetTimeTop;
        var appointmentStartTime;
        var appointmentEndTime;
        var insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);
        var start = moment(targetData.startDate).add(insideOffset, SECONDS);
        if (offsetTimeTopBase === null) {
            offsetTimeTop = moment(targetData.startDate)
                .diff(payload.startDate, SECONDS) + insideOffset;
        }
        else {
            offsetTimeTop = offsetTimeTopBase;
        }
        if (payload.type === targetType) {
            var appointmentDurationSeconds = intervalDuration(payload, SECONDS);
            appointmentStartTime = moment(start).add((offsetTimeTop) * (-1), SECONDS).toDate();
            appointmentEndTime = moment(start)
                .add((appointmentDurationSeconds - offsetTimeTop), SECONDS).toDate();
        }
        else {
            appointmentStartTime = moment(targetData.startDate)
                .add(insideOffset, SECONDS).toDate();
            appointmentEndTime = moment(targetData.endDate).add(insideOffset, SECONDS).toDate();
        }
        return { appointmentStartTime: appointmentStartTime, appointmentEndTime: appointmentEndTime, offsetTimeTop: offsetTimeTop };
    };
    var calculateAppointmentTimeBoundaries = function (payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {
        var isDragging = (payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE);
        return (isDragging
            ? timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase)
            : timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart));
    };
    var calculateInsidePart = function (top, timeTableCellsRects, timeTableIndex) {
        if (timeTableIndex !== undefined && timeTableIndex !== -1) {
            var cellRect = timeTableCellsRects[timeTableIndex]();
            return top > cellRect.top + cellRect.height / 2 ? 1 : 0;
        }
        return 0;
    };
    var calculateDraftAppointments = function (allDayIndex, draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, targetType, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate) {
        if (allDayIndex !== -1 || (targetType === VERTICAL_TYPE
            && getAllDayCellsElementRects.getCellRects.length
            && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23)) {
            var allDayDrafts = draftAppointments.map(function (draftAppt) { return (__assign(__assign({}, draftAppt), { allDay: true })); });
            return {
                allDayDraftAppointments: allDayRects(allDayDrafts, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, grouping, resources, groups, groupOrientation, groupedByDate),
                timeTableDraftAppointments: [],
            };
        }
        if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {
            return {
                allDayDraftAppointments: [],
                timeTableDraftAppointments: verticalTimeTableRects(draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate),
            };
        }
        return {
            allDayDraftAppointments: [],
            timeTableDraftAppointments: horizontalTimeTableRects(draftAppointments, startViewDate, endViewDate, viewCellsData, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate),
        };
    };
    var calculateAppointmentGroups = function (cellGroupingInfo, resources, appointmentData) {
        if (!cellGroupingInfo)
            return {};
        return cellGroupingInfo.reduce(function (acc, group) {
            var _a;
            var isMultipleResource = resources.find(function (resource) { return (resource.fieldName === group.fieldName); }).allowMultiple;
            return __assign(__assign({}, acc), (_a = {}, _a[group.fieldName] = isMultipleResource
                ? updateMultipleResourceInfo(group, appointmentData) : group.id, _a));
        }, {});
    };
    var updateMultipleResourceInfo = function (cellResource, appointmentData) {
        var appointmentGroupItems = appointmentData[cellResource.fieldName];
        if (appointmentGroupItems.findIndex(function (groupItem) { return groupItem === cellResource.id; }) !== -1) {
            return appointmentGroupItems;
        }
        return [cellResource.id];
    };
    var appointmentDragged = function (start, startPrev, end, endPrev, groupingInfo, groupingInfoPrev) {
        if (moment(start).isSame(startPrev)
            && moment(end).isSame(endPrev)
            && groupingInfoNotChanged(groupingInfo, groupingInfoPrev)) {
            return false;
        }
        return true;
    };
    var groupingInfoNotChanged = function (groupingInfo, groupingInfoPrev) {
        var fields = Object.getOwnPropertyNames(groupingInfo);
        return fields.every(function (field) {
            if (Array.isArray(groupingInfo[field]) && Array.isArray(groupingInfoPrev[field])) {
                return groupingInfo[field].every(function (item, index) { return (item === groupingInfoPrev[field][index]); });
            }
            return groupingInfo[field] === groupingInfoPrev[field];
        });
    };

    var isMonthCell = function (otherMonth) { return otherMonth !== undefined; };
    var isShadedAppointment = function (_a, currentTime, shadePreviousAppointments) {
        var appointmentData = _a.data;
        var momentCurrentDate = moment(currentTime);
        if (appointmentData.allDay) {
            return momentCurrentDate.isAfter(appointmentData.endDate, 'day')
                && shadePreviousAppointments;
        }
        if (momentCurrentDate.isAfter(appointmentData.endDate)) {
            return shadePreviousAppointments;
        }
        return false;
    };
    var getCurrentTimeIndicatorTop = function (cellData, currentTime) {
        var top = ((currentTime - cellData.startDate.getTime()) * 100)
            / (cellData.endDate.getTime() - cellData.startDate.getTime());
        return (top < 0 || top > 100) ? undefined : top + "%";
    };
    var isCellShaded = function (_a, currentTime, shadePreviousCells) {
        var startDate = _a.startDate, endDate = _a.endDate, otherMonth = _a.otherMonth;
        var monthCell = isMonthCell(otherMonth);
        return ((startDate.getTime() < currentTime && !monthCell)
            || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;
    };

    var getAppointmentResources = function (appointment, resources, plainResources) {
        if (!resources || resources.length === 0
            || !plainResources || plainResources.length === 0)
            return [];
        return resources.reduce(function (acc, resource) {
            var appointmentResourceId = appointment[resource.fieldName];
            if (appointmentResourceId === undefined)
                return acc;
            if (resource.allowMultiple && !Array.isArray(appointmentResourceId)
                || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {
                // throw error
                return acc;
            }
            if (resource.allowMultiple) {
                return __spread(acc, appointmentResourceId
                    .reduce(function (prevResources, itemId) { return addResourceToAppointmentResources(plainResources, prevResources, resource, itemId); }, []));
            }
            return addResourceToAppointmentResources(plainResources, acc, resource, appointmentResourceId);
        }, []);
    };
    var addResourceToAppointmentResources = function (plainResources, appointmentResources, resource, resourceId) {
        var currentResource = plainResources.find(function (plainItem) { return resource.fieldName === plainItem.fieldName && plainItem.id === resourceId; });
        return currentResource ? __spread(appointmentResources, [
            currentResource,
        ]) : appointmentResources;
    };

    var convertResourcesToPlain = function (validResources) {
        return validResources.reduce(function (acc, resource) { return __spread(acc, resource.instances.map(function (item) { return item; })); }, []);
    };
    var validateResources = function (resources, mainResourceName, palette) {
        var isMainResourceDefined = !!mainResourceName;
        var currentPaletteIndex = 0;
        return resources.map(function (resource, groupIndex) {
            var fieldName = resource.fieldName;
            var isMain = isMainResourceDefined && mainResourceName === fieldName
                || groupIndex === 0 && !isMainResourceDefined;
            var title = resource.title || fieldName;
            var allowMultiple = !!resource.allowMultiple;
            return {
                fieldName: fieldName,
                isMain: isMain,
                title: title,
                allowMultiple: allowMultiple,
                instances: resource.instances.map(function (resourceItem) {
                    var color = resourceItem.color || palette[currentPaletteIndex % palette.length];
                    if (!resourceItem.color)
                        currentPaletteIndex += 1;
                    return ({
                        id: resourceItem.id,
                        color: color,
                        fieldName: fieldName,
                        text: resourceItem.text || title || fieldName,
                        title: title,
                        allowMultiple: allowMultiple,
                        isMain: isMain,
                    });
                }),
            };
        });
    };
    var addResourcesToAppointments = function (appointments, resources, plainResources) { return [
        appointments.map(function (appointment) { return (__assign(__assign({}, appointment), { resources: getAppointmentResources(appointment.dataItem, resources, plainResources) })); }),
    ]; };

    var toggleExpandedGroups = function (state, _a) {
        var groupKey = _a.groupKey;
        var expandedGroups = dxCore.slice(state.expandedGroups);
        var groupKeyIndex = expandedGroups.indexOf(groupKey);
        if (groupKeyIndex > -1) {
            expandedGroups.splice(groupKeyIndex, 1);
        }
        else {
            expandedGroups.push(groupKey);
        }
        return { expandedGroups: expandedGroups };
    };

    var getDayScaleCellColSpan = function (cellsData) {
        var firstDate = cellsData[0][0].startDate;
        var count = 1;
        while (cellsData[0][count] && moment(cellsData[0][count].startDate).isSame(firstDate, 'day')) {
            count += 1;
        }
        return count;
    };
    var getDayScaleCells = function (cellsData, groupedByDate) {
        if (!groupedByDate) {
            return cellsData[0].map(function (_a, index) {
                var startDate = _a.startDate, endDate = _a.endDate, today = _a.today, endOfGroup = _a.endOfGroup, groupingInfo = _a.groupingInfo;
                return ({
                    key: index.toString(),
                    startDate: startDate, endDate: endDate, today: today, endOfGroup: endOfGroup, groupingInfo: groupingInfo,
                });
            });
        }
        var prevDate;
        var colSpan = getDayScaleCellColSpan(cellsData);
        return cellsData[0].reduce(function (acc, _a, index) {
            var startDate = _a.startDate, endDate = _a.endDate, today = _a.today;
            var currentDate = moment(startDate);
            if (currentDate.isSame(prevDate)) {
                return acc;
            }
            prevDate = currentDate;
            return __spread(acc, [
                {
                    key: index.toString(),
                    startDate: startDate, endDate: endDate, today: today, colSpan: colSpan,
                    endOfGroup: true,
                },
            ]);
        }, []);
    };

    var navigateByOneMonth = function (currentDate, isBackward) { return moment(currentDate)[isBackward ? 'subtract' : 'add'](1, 'month').toDate(); };

    (function (RecurrenceFrequency) {
        RecurrenceFrequency[RecurrenceFrequency["Daily"] = RRULE_REPEAT_TYPES.DAILY] = "Daily";
        RecurrenceFrequency[RecurrenceFrequency["Weekly"] = RRULE_REPEAT_TYPES.WEEKLY] = "Weekly";
        RecurrenceFrequency[RecurrenceFrequency["Monthly"] = RRULE_REPEAT_TYPES.MONTHLY] = "Monthly";
        RecurrenceFrequency[RecurrenceFrequency["Yearly"] = RRULE_REPEAT_TYPES.YEARLY] = "Yearly";
    })(exports.RecurrenceFrequency || (exports.RecurrenceFrequency = {}));

    exports.APRIL_DATE = APRIL_DATE;
    exports.AUGUST_DATE = AUGUST_DATE;
    exports.AUTO_HEIGHT = AUTO_HEIGHT;
    exports.BASIC_DAILY_COUNT = BASIC_DAILY_COUNT;
    exports.BASIC_MONTHLY_COUNT = BASIC_MONTHLY_COUNT;
    exports.BASIC_WEEKLY_COUNT = BASIC_WEEKLY_COUNT;
    exports.BASIC_YEALY_COUNT = BASIC_YEALY_COUNT;
    exports.CANCEL_BUTTON = CANCEL_BUTTON;
    exports.CANCEL_COMMAND_BUTTON = CANCEL_COMMAND_BUTTON;
    exports.CLOSE_COMMAND_BUTTON = CLOSE_COMMAND_BUTTON;
    exports.COMMIT_COMMAND_BUTTON = COMMIT_COMMAND_BUTTON;
    exports.DAYS_IN_WEEK = DAYS_IN_WEEK;
    exports.DAYS_OF_WEEK = DAYS_OF_WEEK;
    exports.DAYS_OF_WEEK_ARRAY = DAYS_OF_WEEK_ARRAY;
    exports.DAYS_OF_WEEK_DATES = DAYS_OF_WEEK_DATES;
    exports.DAY_LONG_MONTH_LONG_YEAR_OPTIONS = DAY_LONG_MONTH_LONG_YEAR_OPTIONS;
    exports.DAY_LONG_MONTH_OPTIONS = DAY_LONG_MONTH_OPTIONS;
    exports.DAY_OPTIONS = DAY_OPTIONS;
    exports.DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = DAY_SHORT_MONTH_LONG_YEAR_OPTIONS;
    exports.DAY_SHORT_MONTH_OPTIONS = DAY_SHORT_MONTH_OPTIONS;
    exports.DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS;
    exports.DECEMBER_DATE = DECEMBER_DATE;
    exports.DEFAULT_RULE_OBJECT = DEFAULT_RULE_OBJECT;
    exports.DELETE_BUTTON = DELETE_BUTTON;
    exports.DELETE_COMMAND_BUTTON = DELETE_COMMAND_BUTTON;
    exports.EMPTY_OPTIONS = EMPTY_OPTIONS;
    exports.END_REPEAT_RADIO_GROUP = END_REPEAT_RADIO_GROUP;
    exports.FEBRUARY_DATE = FEBRUARY_DATE;
    exports.FIRST_WEEK = FIRST_WEEK;
    exports.FOURTH_WEEK = FOURTH_WEEK;
    exports.FRIDAY_DATE = FRIDAY_DATE;
    exports.HORIZONTAL_GROUP_ORIENTATION = HORIZONTAL_GROUP_ORIENTATION;
    exports.HORIZONTAL_TYPE = HORIZONTAL_TYPE;
    exports.HORIZONTAL_VIEW_LEFT_OFFSET = HORIZONTAL_VIEW_LEFT_OFFSET;
    exports.HOURS = HOURS;
    exports.HOUR_MINUTE_OPTIONS = HOUR_MINUTE_OPTIONS;
    exports.JANUARY_DATE = JANUARY_DATE;
    exports.JULY_DATE = JULY_DATE;
    exports.JUNE_DATE = JUNE_DATE;
    exports.LAST_WEEK = LAST_WEEK;
    exports.LONG_MONTH_OPTIONS = LONG_MONTH_OPTIONS;
    exports.LONG_WEEK_DAY_OPTIONS = LONG_WEEK_DAY_OPTIONS;
    exports.MARCH_DATE = MARCH_DATE;
    exports.MAY_DATE = MAY_DATE;
    exports.MINUTES = MINUTES;
    exports.MONDAY_DATE = MONDAY_DATE;
    exports.MONTHLY_RADIO_GROUP = MONTHLY_RADIO_GROUP;
    exports.MONTHS = MONTHS;
    exports.MONTHS_DATES = MONTHS_DATES;
    exports.MONTH_YEAR_OPTIONS = MONTH_YEAR_OPTIONS;
    exports.MULTILINE_TEXT_EDITOR = MULTILINE_TEXT_EDITOR;
    exports.NOVEMBER_DATE = NOVEMBER_DATE;
    exports.NUMBER_EDITOR = NUMBER_EDITOR;
    exports.OCTOBER_DATE = OCTOBER_DATE;
    exports.OPEN_COMMAND_BUTTON = OPEN_COMMAND_BUTTON;
    exports.ORDINARY_LABEL = ORDINARY_LABEL;
    exports.ORDINARY_TEXT_EDITOR = ORDINARY_TEXT_EDITOR;
    exports.OUTLINED_SELECT = OUTLINED_SELECT;
    exports.POSITION_END = POSITION_END;
    exports.POSITION_START = POSITION_START;
    exports.RECURRENCE_EDIT_SCOPE = RECURRENCE_EDIT_SCOPE;
    exports.REPEAT_TYPES = REPEAT_TYPES;
    exports.REPEAT_TYPES_ARRAY = REPEAT_TYPES_ARRAY;
    exports.RESIZE_BOTTOM = RESIZE_BOTTOM;
    exports.RESIZE_TOP = RESIZE_TOP;
    exports.RRULE_DAYS_OF_WEEK = RRULE_DAYS_OF_WEEK;
    exports.RRULE_REPEAT_TYPES = RRULE_REPEAT_TYPES;
    exports.SATURDAY_DATE = SATURDAY_DATE;
    exports.SAVE_BUTTON = SAVE_BUTTON;
    exports.SCROLL_OFFSET = SCROLL_OFFSET;
    exports.SCROLL_SPEED_PX = SCROLL_SPEED_PX;
    exports.SECONDS = SECONDS;
    exports.SECOND_WEEK = SECOND_WEEK;
    exports.SEPTEMBER_DATE = SEPTEMBER_DATE;
    exports.SHORT_MONTH_LONG_YEAR_OPTIONS = SHORT_MONTH_LONG_YEAR_OPTIONS;
    exports.SHORT_MONTH_OPTIONS = SHORT_MONTH_OPTIONS;
    exports.SHORT_MONTH_SHORT_YEAR_OPTIONS = SHORT_MONTH_SHORT_YEAR_OPTIONS;
    exports.STANDARD_SELECT = STANDARD_SELECT;
    exports.SUNDAY_DATE = SUNDAY_DATE;
    exports.THIRD_WEEK = THIRD_WEEK;
    exports.THURSDAY_DATE = THURSDAY_DATE;
    exports.TITLE = TITLE;
    exports.TITLE_TEXT_EDITOR = TITLE_TEXT_EDITOR;
    exports.TOGGLE_APPOINTMENT_FORM_VISIBILITY = TOGGLE_APPOINTMENT_FORM_VISIBILITY;
    exports.TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY;
    exports.TUESDAY_DATE = TUESDAY_DATE;
    exports.VERTICAL_GROUP_ORIENTATION = VERTICAL_GROUP_ORIENTATION;
    exports.VERTICAL_TYPE = VERTICAL_TYPE;
    exports.VERTICAL_VIEW_LEFT_OFFSET = VERTICAL_VIEW_LEFT_OFFSET;
    exports.VIEW_TYPES = VIEW_TYPES;
    exports.WEDNESDAY_DATE = WEDNESDAY_DATE;
    exports.WEEKDAY_INTERVAL = WEEKDAY_INTERVAL;
    exports.WEEK_DAY_OPTIONS = WEEK_DAY_OPTIONS;
    exports.WEEK_NUMBER_LABELS = WEEK_NUMBER_LABELS;
    exports.YEARLY_RADIO_GROUP = YEARLY_RADIO_GROUP;
    exports.addAppointment = addAppointment;
    exports.addDateToKey = addDateToKey;
    exports.addGroupInfoToCell = addGroupInfoToCell;
    exports.addGroupInfoToCells = addGroupInfoToCells;
    exports.addResourcesToAppointments = addResourcesToAppointments;
    exports.adjustByBlocks = adjustByBlocks;
    exports.allDayCells = allDayCells;
    exports.allDayPredicate = allDayPredicate;
    exports.allDayRects = allDayRects;
    exports.appointmentDragged = appointmentDragged;
    exports.appointments = appointments;
    exports.areDatesSame = areDatesSame;
    exports.autoScroll = autoScroll;
    exports.availableViews = availableViews;
    exports.calculateAllDayDateIntervals = calculateAllDayDateIntervals;
    exports.calculateAppointmentGroups = calculateAppointmentGroups;
    exports.calculateAppointmentLeftAndWidth = calculateAppointmentLeftAndWidth;
    exports.calculateAppointmentOffsets = calculateAppointmentOffsets;
    exports.calculateAppointmentTimeBoundaries = calculateAppointmentTimeBoundaries;
    exports.calculateAppointmentsMetaData = calculateAppointmentsMetaData;
    exports.calculateBlocksLeftLimit = calculateBlocksLeftLimit;
    exports.calculateBlocksTotalSize = calculateBlocksTotalSize;
    exports.calculateDraftAppointments = calculateDraftAppointments;
    exports.calculateFirstDateOfWeek = calculateFirstDateOfWeek;
    exports.calculateIncludedBlockMaxRight = calculateIncludedBlockMaxRight;
    exports.calculateInsidePart = calculateInsidePart;
    exports.calculateMonthDateIntervals = calculateMonthDateIntervals;
    exports.calculateRectByDateAndGroupIntervals = calculateRectByDateAndGroupIntervals;
    exports.calculateWeekDateIntervals = calculateWeekDateIntervals;
    exports.callActionIfExists = callActionIfExists;
    exports.cancelAddedAppointment = cancelAddedAppointment;
    exports.cancelChanges = cancelChanges;
    exports.cellData = cellData;
    exports.cellIndex = cellIndex;
    exports.cellType = cellType;
    exports.changeAppointment = changeAppointment;
    exports.changeCurrentDate = changeCurrentDate;
    exports.changeRecurrenceFrequency = changeRecurrenceFrequency;
    exports.changeRecurrenceOptions = changeRecurrenceOptions;
    exports.changedAppointmentById = changedAppointmentById;
    exports.checkCellGroupingInfo = checkCellGroupingInfo;
    exports.checkIsNaturalNumber = checkIsNaturalNumber;
    exports.checkMultipleResourceFields = checkMultipleResourceFields;
    exports.computed = computed;
    exports.containsDSTChange = containsDSTChange;
    exports.convertResourcesToPlain = convertResourcesToPlain;
    exports.convertToMoment = convertToMoment;
    exports.createAppointmentForest = createAppointmentForest;
    exports.dayBoundaryPredicate = dayBoundaryPredicate;
    exports.dayScale = dayScale;
    exports.deleteAll = deleteAll;
    exports.deleteCurrent = deleteCurrent;
    exports.deleteCurrentAndFollowing = deleteCurrentAndFollowing;
    exports.editAll = editAll;
    exports.editCurrent = editCurrent;
    exports.editCurrentAndFollowing = editCurrentAndFollowing;
    exports.endViewDate = endViewDate;
    exports.excludedIntervals = excludedIntervals;
    exports.expandGroupedAppointment = expandGroupedAppointment;
    exports.expandGroups = expandGroups;
    exports.expandViewCellsDataWithGroups = expandViewCellsDataWithGroups;
    exports.filterByViewBoundaries = filterByViewBoundaries;
    exports.filterResourcesByGrouping = filterResourcesByGrouping;
    exports.findBlockIndexByAppointment = findBlockIndexByAppointment;
    exports.findChildBlocks = findChildBlocks;
    exports.findChildrenMaxEndDate = findChildrenMaxEndDate;
    exports.findIncludedBlocks = findIncludedBlocks;
    exports.findMaxReduceValue = findMaxReduceValue;
    exports.findOverlappedAppointments = findOverlappedAppointments;
    exports.formatDateTimeGetter = formatDateTimeGetter;
    exports.formatDateToString = formatDateToString;
    exports.getAllDayCellIndexByAppointmentData = getAllDayCellIndexByAppointmentData;
    exports.getAllDayHorizontallyGroupedColumnIndex = getAllDayHorizontallyGroupedColumnIndex;
    exports.getAllDayVerticallyGroupedColumnIndex = getAllDayVerticallyGroupedColumnIndex;
    exports.getAllDayVerticallyGroupedRowIndex = getAllDayVerticallyGroupedRowIndex;
    exports.getAppointmentResources = getAppointmentResources;
    exports.getAppointmentStyle = getAppointmentStyle;
    exports.getAvailableRecurrenceOptions = getAvailableRecurrenceOptions;
    exports.getCellKey = getCellKey;
    exports.getCountDependingOnRecurrenceType = getCountDependingOnRecurrenceType;
    exports.getCurrentTimeIndicatorTop = getCurrentTimeIndicatorTop;
    exports.getDayScaleCellColSpan = getDayScaleCellColSpan;
    exports.getDayScaleCells = getDayScaleCells;
    exports.getDaysOfWeek = getDaysOfWeek;
    exports.getDaysOfWeekArray = getDaysOfWeekArray;
    exports.getDaysOfWeekDates = getDaysOfWeekDates;
    exports.getFrequencyString = getFrequencyString;
    exports.getGroupFromResourceInstance = getGroupFromResourceInstance;
    exports.getGroupingInfoFromGroups = getGroupingInfoFromGroups;
    exports.getGroupsFromResources = getGroupsFromResources;
    exports.getGroupsLastRow = getGroupsLastRow;
    exports.getHorizontalRectByAppointmentData = getHorizontalRectByAppointmentData;
    exports.getLabelsForAllGroups = getLabelsForAllGroups;
    exports.getMonthCellIndexByAppointmentData = getMonthCellIndexByAppointmentData;
    exports.getMonthHorizontallyGroupedColumnIndex = getMonthHorizontallyGroupedColumnIndex;
    exports.getMonthVerticallyGroupedRowIndex = getMonthVerticallyGroupedRowIndex;
    exports.getMonths = getMonths;
    exports.getMonthsWithOf = getMonthsWithOf;
    exports.getRRuleFrequency = getRRuleFrequency;
    exports.getRRuleSetWithExDates = getRRuleSetWithExDates;
    exports.getRadioGroupDisplayData = getRadioGroupDisplayData;
    exports.getRecurrenceOptions = getRecurrenceOptions;
    exports.getRowFromGroups = getRowFromGroups;
    exports.getTimeTableHeight = getTimeTableHeight;
    exports.getUTCDate = getUTCDate;
    exports.getVerticalCellIndexByAppointmentData = getVerticalCellIndexByAppointmentData;
    exports.getVerticalRectByAppointmentData = getVerticalRectByAppointmentData;
    exports.getVerticalRowFromGroups = getVerticalRowFromGroups;
    exports.getViewType = getViewType;
    exports.getWeekHorizontallyGroupedColumnIndex = getWeekHorizontallyGroupedColumnIndex;
    exports.getWeekHorizontallyGroupedRowIndex = getWeekHorizontallyGroupedRowIndex;
    exports.getWeekNumberLabels = getWeekNumberLabels;
    exports.getWeekVerticallyGroupedColumnIndex = getWeekVerticallyGroupedColumnIndex;
    exports.getWeekVerticallyGroupedRowIndex = getWeekVerticallyGroupedRowIndex;
    exports.groupAppointments = groupAppointments;
    exports.groupAppointmentsIntoBlocks = groupAppointmentsIntoBlocks;
    exports.handleChangeFrequency = handleChangeFrequency;
    exports.handleStartDateChange = handleStartDateChange;
    exports.handleToDayOfWeekChange = handleToDayOfWeekChange;
    exports.handleWeekDaysChange = handleWeekDaysChange;
    exports.horizontalTimeTableRects = horizontalTimeTableRects;
    exports.intervalDuration = intervalDuration;
    exports.intervalIncludes = intervalIncludes;
    exports.isAllDayCell = isAllDayCell;
    exports.isAllDayElementsMetaActual = isAllDayElementsMetaActual;
    exports.isCellShaded = isCellShaded;
    exports.isDateValid = isDateValid;
    exports.isMidnight = isMidnight;
    exports.isMonthCell = isMonthCell;
    exports.isOverlappingSubTreeRoot = isOverlappingSubTreeRoot;
    exports.isPossibleChild = isPossibleChild;
    exports.isShadedAppointment = isShadedAppointment;
    exports.isTimeTableElementsMetaActual = isTimeTableElementsMetaActual;
    exports.monthCellsData = monthCellsData;
    exports.navigateByOneMonth = navigateByOneMonth;
    exports.normalizeAppointmentDuration = normalizeAppointmentDuration;
    exports.preCommitChanges = preCommitChanges;
    exports.prepareToGroupIntoBlocks = prepareToGroupIntoBlocks;
    exports.prepareVerticalViewCellsData = prepareVerticalViewCellsData;
    exports.rearrangeResources = rearrangeResources;
    exports.reduceAppointmentByDayBounds = reduceAppointmentByDayBounds;
    exports.setAppointmentData = setAppointmentData;
    exports.setAppointmentMeta = setAppointmentMeta;
    exports.setCurrentViewName = setCurrentViewName;
    exports.sliceAppointmentByDay = sliceAppointmentByDay;
    exports.sliceAppointmentByWeek = sliceAppointmentByWeek;
    exports.sliceAppointmentsByBoundaries = sliceAppointmentsByBoundaries;
    exports.sliceAppointmentsByDays = sliceAppointmentsByDays;
    exports.sortAppointments = sortAppointments;
    exports.sortFilteredResources = sortFilteredResources;
    exports.startEditAppointment = startEditAppointment;
    exports.startViewDate = startViewDate;
    exports.stopEditAppointment = stopEditAppointment;
    exports.timeBoundariesByDrag = timeBoundariesByDrag;
    exports.timeBoundariesByResize = timeBoundariesByResize;
    exports.timeCellsData = timeCellsData;
    exports.timeScale = timeScale;
    exports.toPercentage = toPercentage;
    exports.toggleExpandedGroups = toggleExpandedGroups;
    exports.unwrapGroups = unwrapGroups;
    exports.updateAllDayCellElementsMeta = updateAllDayCellElementsMeta;
    exports.updateBlocksLeft = updateBlocksLeft;
    exports.updateBlocksProportions = updateBlocksProportions;
    exports.updateGroupingWithMainResource = updateGroupingWithMainResource;
    exports.updateTimeCellsData = updateTimeCellsData;
    exports.updateTimeTableCellElementsMeta = updateTimeTableCellElementsMeta;
    exports.validateResources = validateResources;
    exports.verticalTimeTableRects = verticalTimeTableRects;
    exports.viewBoundText = viewBoundText;
    exports.viewCellsData = viewCellsData;
    exports.viewPredicate = viewPredicate;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=dx-scheduler-core.umd.js.map
